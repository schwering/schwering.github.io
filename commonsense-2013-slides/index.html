<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- vim:textwidth=80:shiftwidth=2:softtabstop=2:expandtab
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-US">
<head>
  <title>Spatio-Temporal Reasoning about Traffic Scenarios</title>
  <meta name="copyright" content="C. Schwering, G. Lakemeyer, &nbsp;&nbsp; Knowledge-Based Systems Group, &nbsp;&nbsp; RWTH Aachen University" />
  <meta name="duration" content="20" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

  <script type="text/javascript">
    function texScale() {
      var scale = undefined;
      if (window.innerHeight <= 600 || window.innerWidth <= 800) {
        scale = 92;
      } else if (window.innerHeight <= 864 || window.innerWidth <= 1152) {
      //} else if (window.innerHeight <= 800 || window.innerWidth <= 1024) {
        scale = 90;
      } else {
        scale = 100;
      }
      console.log("MathJax scale = "+ scale);
      return scale;
    }
  </script>

  <script type="text/x-mathjax-config">
    "use strict";

    MathJax.Hub.Config({
      showProcessingMessages: false,
      tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
      TeX: { equationNumbers: { autoNumber: "AMS" } },
      "HTML-CSS": {
        availableFonts: ["TeX"], // this avoids ugly STIX fonts when installed at the client
        scale: texScale()
      },
      extensions: ["tex2jax.js"],
      jax: ["input/TeX","output/HTML-CSS"],
    });
  </script>
  <!--
  For some reason, the unpacked MathJax does not have the occasional display
  errors.  The placement of the math symbols is messed up in about 30% of the
  page loads when a HTML5 video is embedded.
  Fix number one was to embed HTML5 videos dynamically which reduced the
  display errors to maybe 5% or less.
  Then I tried to fix it by forcing MathJax to re-render by calling
    MathJax.Hub.setRenderer("SVG");
  because manually re-rendering with the right-click menu fixes the display
  errors.  However, setRenderer() works only for the *unpacked* MathJax.
  And the unpacked MathJax apparently doesn't even have these errors.
  -->

  <!--
  We do it dynamically in window.onload() now, because this apparently avoids
  rendering errors:
  <script type="text/javascript" src="MathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  -->

  <script type="text/javascript">
    "use strict";

    function loadRemoteMathJaxIfNecessary() {
      // take the same protocol to access MathJax as for accessing the slides.
      // exception: when the slides are accessed locally, use http for MathJax
      var path = "//cdn.mathjax.org/mathjax/latest";
      if (location.protocol.toLowerCase().indexOf("http") != 0) {
        path = "http:" + path;
      }
      loadMathJaxIfNecessary(path);
    }

    function loadMathJaxIfNecessary(path) {
      var remote = path.indexOf("http") == 0;

      if (window.MathJax != undefined) { // already loaded
        return;
      }

      if (remote) {
        setTimeout(function () {
          if (location.protocol.toLowerCase().indexOf("http") == 0) {
            // for visitors over the Internet, loading MathJax from the MathJax-servers
            // is totally fine; maybe it's even faster due to client-side caching
            return;
          }

          var mathJaxPrompt = document.createElement("div");
          mathJaxPrompt.style.position = "absolute";
          mathJaxPrompt.style.left = "25%";
          mathJaxPrompt.style.bottom = "10%";
          mathJaxPrompt.style.width = "50%";
          //mathJaxPrompt.style.height = "43%";
          mathJaxPrompt.style.backgroundColor = "orange";
          mathJaxPrompt.style.borderWidth = "thick";
          mathJaxPrompt.style.borderColor = "black";
          mathJaxPrompt.style.borderStyle = "solid";
          mathJaxPrompt.style.overflow = "auto";
          mathJaxPrompt.style.zIndex = "99";

          mathJaxPrompt.innerHTML = 
            "<p>You have no local copy of MathJax (in <code>./MathJax<\/code>).<\/p>"+
            "<p>I'm trying to load MathJax dynamically. If we don't have an Internet connection, "+
            "this will fail and LaTeX formulas won't be typeset.<\/p>"+
            "<p>You can <a href=\"https://github.com/mathjax/MathJax/zipball/v2.0-latest\">download MathJax<\/a>, "+
            "extract the ZIP-file and move the created folder to <code>./MathJax<\/code>, or run <code>./download.sh<\/code>."+
            "<p>Click to hide this message.<\/p>";

          document.body.appendChild(mathJaxPrompt);

          mathJaxPrompt.addEventListener("click", function (e) {
            document.body.removeChild(mathJaxPrompt);
            if (e.cancel != undefined)
              e.cancel = true;
            if (e.returnValue != undefined)
              e.returnValue = false;
            e.stopPropagation();
          }, false);

          setTimeout(function() { document.body.removeChild(mathJaxPrompt); }, 20000);
        }, 1000);
      }

      var script = document.createElement("script");
      script.type = "text/javascript";
      script.src = path + "/MathJax.js?config=TeX-AMS-MML_HTMLorMML";

      var scale = texScale();
      var config = 'MathJax.Hub.Config({' +
                     'showProcessingMessages: false,' +
                     '"HTML-CSS": { scale: '+ scale +' },' +
                     'extensions: ["tex2jax.js"],' +
                     'jax: ["input/TeX","output/HTML-CSS"],' +
                   '});' +
                   'MathJax.Hub.Startup.onload();';

      if (window.opera) {script.innerHTML = config}
                   else {script.text = config}

      document.getElementsByTagName("head")[0].appendChild(script);
    };
  </script>

  <link rel="stylesheet" href="styles/slidy.css" type="text/css" />
  <link rel="stylesheet" href="styles/fonts.css" type="text/css" />
  <link rel="stylesheet" href="styles/kbsg.css" type="text/css" />
  <link rel="stylesheet" href="styles/kbsg-cover.css" type="text/css" />
  <link rel="stylesheet" href="styles/list.css" type="text/css" />
  <link rel="stylesheet" href="styles/outline.css" type="text/css" />
  <link rel="stylesheet" href="styles/custom.css" type="text/css" />
  <link rel="stylesheet" href="styles/print.css" type="text/css" />

  <script src="scripts/slidy.js" charset="utf-8" type="text/javascript"></script>
  <script type="text/javascript">
    "use strict";

    /* These objects are associative arrays with keys `slide IDs' and
     * values `function (slide) { ... }'.
     * The idea is that the show/hide handler for each slide checks whether
     * or not there is a initializer/finalizer stored for the current slide
     * using the slide's ID and, if so, calls it.
     */
    var slideInitializers = new Object();
    var slideFinalizers = new Object();

    function addSlideInitializer(slideId, handler) {
      if (slideInitializers[slideId] == undefined)
        slideInitializers[slideId] = new Array();
      slideInitializers[slideId].push(handler);
    }

    function addSlideFinalizer(slideId, handler) {
      if (slideFinalizers[slideId] == undefined)
        slideFinalizers[slideId] = new Array();
      slideFinalizers[slideId].push(handler);
    }

    w3c_slidy.set_show_slide_handler(function (slide) {
      /* Loading videos lazily might fix the display errors in MathJax. */
      var videoContainers = slide.getElementsByClassName("video-container");
      for (var i = 0; i < videoContainers.length; ++i) {
        var vc = videoContainers[i];
        var videoName = vc.id;
        if (vc.innerHTML == null || vc.innerHTML.length == 0) {
          /* You can set a poster with <video poster="path/poster.jpg"> and
           * you can enable controls with <video controls="controls"> but
           * we have disabled controls because sometimes the 'Play' button does
           * not disappear in Firefox (this is probably due to the dynamically
           * loading. */
          vc.innerHTML =
            '<video class="video" preload="auto" poster="videos/'+ videoName +'.png">'+
            '<source src="videos/'+ videoName +'.webm" type="video/webm" />'
            '<\/video>';
        }
      }

      /* We play()/pause() videos when a slide is shown/hidden. */
      var videos = slide.getElementsByClassName("video");
      for (var i = 0; i < videos.length; ++i) {
        videos[i].play();
      }

      /* Call initializers. */
      if (slide.id != undefined && slideInitializers[slide.id] != undefined) {
        var arr = slideInitializers[slide.id];
        for (var i = 0; i < arr.length; ++i) {
          arr[i](slide);
        }
      }
    });

    w3c_slidy.set_hide_slide_handler(function (slide) {
      /* We play()/pause() videos when a slide is shown/hidden. */
      var videos = slide.getElementsByClassName("video");  
      for (var i = 0; i < videos.length; ++i) {
        videos[i].pause();
      }

      /* Call finalizers. */
      if (slide.id != undefined && slideFinalizers[slide.id] != undefined) {
        var arr = slideFinalizers[slide.id];
        for (var i = 0; i < arr.length; ++i) {
          arr[i](slide);
        }
      }
    });

    w3c_slidy.set_resize_handler(function () {
      if (window.MathJax && MathJax.Hub && MathJax.Hub.Reprocess) {
        MathJax.Hub.Reprocess();
      }
    });


    /* These objects are associative arrays with keys `node IDs' and
     * values `function (slide, node) { ... }'.
     * The idea is that the show/hide handler for each node checks whether
     * or not there is a initializer/finalizer stored for the current node
     * using the node's ID and, if so, calls it.
     */
    var nodeInitializers = new Object();
    var nodeFinalizers = new Object();

    function setNodeInitializer(nodeId, handler) {
      nodeInitializers[nodeId] = handler;
    }

    function setNodeFinalizer(nodeId, handler) {
      nodeFinalizers[nodeId] = handler;
    }

    w3c_slidy.set_show_node_handler(function (node) {
      if (node.id != undefined && nodeInitializers[node.id] != undefined) {
        nodeInitializers[node.id](node);
      }
    });

    w3c_slidy.set_hide_node_handler(function (node) {
      if (node.id != undefined && nodeFinalizers[node.id] != undefined) {
        nodeFinalizers[node.id](node);
      }
    });

    if (location.search.indexOf("time=true") != -1) {
      w3c_slidy.set_display_time(true);
    } else {
      w3c_slidy.set_display_time(false);
    }
  </script>

  <script type="text/javascript">
    "use strict";

    function rad2deg(rad) {
      return rad / Math.PI * 180;
    }

    function removeChildren(ids) {
      if (!is_array(ids))
        ids = new Array(ids);
      for (var i = 0; i < ids.length; ++i) {
        var e = document.getElementById(ids[i]);
        for (var n = e.firstChild; n; ) {
          if (!w3c_slidy.has_class(n, "unremovable")) {
            e.removeChild(n);
            n = e.firstChild;
          } else {
            n = n.nextSibling;
          }
        }
      }
    }

    function is_array(input) {
      return typeof(input) == "object" && (input instanceof Array);
    }

    /* A timer that synchronously executes a number of handlers.
     * Similar to setInterval() except that all handlers are executed
     * right after another and thus are kept in sync over a long period. */
    function Timer() {
      this.events = new Array(); /* { ticks: int, func: func() { ... } } */
      this.now = 0;
      this.doPause = false;

      var PERIOD = 10;
      var timer = this;
      function loop() {
        if (timer.doPause) {
          return;
        }
        for (var i = timer.events.length - 1; i >= 0; --i) {
          if (timer.events[i] != undefined &&
              timer.now >= timer.events[i].ticks) {
            timer.events[i].func();
            timer.events.splice(i, 1);
          }
        }
        timer.now += PERIOD;
      }

      this.interval = setInterval(loop, PERIOD);

      this.secs = function () { return this.now / 1000; }
      this.play = function () { this.doPause = false; }
      this.pause = function () { this.doPause = true; }
      this.stop = function () { clearInterval(this.interval); }
      this.addEvent = function (func, secs) {
        var ticks = secs * 1000;
        this.events.push({ ticks: this.now + ticks, func: func });
      }
    }

    var SCALE = 0.1;

    function Rstc(measurements) {
      var cars = {};
      var ntg = {};
      var ttc = {};

      for (var b in measurements) {
        cars[b] = true;
        for (var c in measurements[b]) {
          cars[c] = true;
        }
      }

      for (var b in cars) {
        ntg[b] = {};
        ttc[b] = {};
      }

      for (var b in cars) {
        for (var c in cars) {
          if (measurements[b] != undefined && measurements[b][c] != undefined) {
            if (measurements[b][c].ntg != undefined) {
              ntg[b][c] = measurements[b][c].ntg;
            }
            if (measurements[b][c].ttc != undefined) {
              ttc[b][c] = measurements[b][c].ttc;
            }
          }
        }
      }

      var change = false;
      do {
        change = false;
        for (var b in cars) {
          for (var c in cars) {
            if (b != c &&
                ntg[b][c] != undefined && ttc[b][c] != undefined &&
                ntg[c][b] == undefined && ttc[c][b] == undefined) {
              ntg[c][b] = -1 / (1 - ntg[b][c] / ttc[b][c]) * ntg[b][c];
              ttc[c][b] = ttc[b][c];
              change = true;
            }
          }
        }

        for (var b in cars) {
          for (var c in cars) {
            for (var d in cars) {
              if (b != c && c != d && b != d &&
                  ntg[b][c] != undefined && ttc[b][c] != undefined &&
                  ntg[c][d] != undefined && ttc[c][d] != undefined &&
                  ntg[b][d] == undefined && ttc[b][d] == undefined) {
                ntg[b][d] = ntg[b][c] + (1 - ntg[b][c] / ttc[b][c]) * ntg[c][d];
                var l1 = (ttc[c][d] * ntg[b][c]) / (ntg[c][d] * ttc[b][c] + ttc[c][d] * ntg[b][c] - ntg[c][d] * ntg[b][c]);
                var l2 = (ttc[b][c] * ntg[c][d] - ntg[b][c] * ntg[c][d]) / (ntg[b][c] * ttc[c][d] + ttc[b][c] * ntg[c][d] - ntg[b][c] * ntg[c][d]);
                ttc[b][d] = l1 * ttc[b][c] + l2 * ttc[c][d];
                change = true;
              }
            }
          }
        }
      } while (change);

      this.cars = cars;
      this.ntg = function (b, c) { return ntg[b][c]; }
      this.ttc = function (b, c) { /*alert("t = 0 ==> "+ (ttc[b][c]));*/ return ttc[b][c]; }
    };

    // The x position of b if c is the reference car.
    // If c is undefined, the reference car is determined automatically.
    Rstc.prototype.x = function (b, c) {
      if (c == undefined) {
        c = this.computeReferenceCar();
      }
      if (b == c) {
        return 0;
      }
      var ntg = this.ntg;
      var ttc = this.ttc;
      var ret = -1 * ntg(b,c) * (1 - ntg(c,b) / ttc(c,b));
      return isNaN(ret) ? 0 : ret;
    };

    Rstc.prototype.v = function (b) {
      var c = this.computeReferenceCar();
      if (b == c) {
        return 1;
      }
      var ntg = this.ntg;
      var ttc = this.ttc;
      var ret = 1 - ntg(c,b) / ttc(c,b);
      return isNaN(ret) ? 0 : ret;
    };

    // Reference car for visualization is:
    // arg min_c max_b |x(b,c)|
    Rstc.prototype.computeReferenceCar = function () {
      if (this.referenceCar != undefined) {
        return this.referenceCar;
      }
      var min = undefined;
      for (var c in this.cars) {
        var max = undefined;
        for (var b in this.cars) {
          var tmp = Math.abs(this.x(b, c));
          if (max == undefined || tmp > max) {
            max = tmp;
          }
        }
        if (min == undefined || max < min) {
          min = max;
          this.referenceCar = c;
        }
      }
      return this.referenceCar;
    };

    Rstc.prototype.forceReferenceCar = function (b) {
      this.referenceCar = b;
    };

    Rstc.prototype.progress = function () {
      function EmptyRstc() {};
      EmptyRstc.prototype = Rstc.prototype;
      var rstc = new EmptyRstc();
      var ntg = {};
      var ttc = {};
      for (var b in this.cars) {
        ntg[b] = {};
        ttc[b] = {};
        for (var c in this.cars) {
          ntg[b][c] = this.ntg(b,c);
          ttc[b][c] = this.ttc(b,c);
        }
      }
      rstc.cars = this.cars;
      rstc.ntg = function (b, c) { return ntg[b][c]; }
      rstc.ttc = function (b, c) { return ttc[b][c]; }
      rstc.referenceCar = this.computeReferenceCar();
      return rstc;
    }

    Rstc.prototype.wait = function (t) {
      var ntg = this.ntg;
      var ttc = this.ttc;
      function WaitRstc() {};
      WaitRstc.prototype = Rstc.prototype;
      var rstc = new WaitRstc();
      rstc.t = t;
      rstc.time = function (t) { if (t != undefined) { this.t = t; } return this.t; };
      rstc.cars = this.cars;
      rstc.ntg = function (b, c) { return ntg(b,c) - rstc.time() * ntg(b,c) / ttc(b,c); }
      rstc.ttc = function (b, c) { return ttc(b,c) - rstc.time(); }
      rstc.referenceCar = this.computeReferenceCar();
      return rstc;
    }

    Rstc.prototype.accel = function (bb, q) {
      var ntg = this.ntg;
      var ttc = this.ttc;
      function AccelRstc() {};
      AccelRstc.prototype = Rstc.prototype;
      var rstc = new AccelRstc();
      rstc.cars = this.cars;
      rstc.ntg = function (b, c) {
        if (b == bb) {
          return 1/q * ntg(b,c);
        } else {
          return ntg(b,c);
        }
      };
      rstc.ttc = function (b, c) {
        if (b == bb) {
          return 1 / ((q - 1) * ttc(b,c) / ntg(b,c) + 1) * ttc(b,c);
        } else if (c == bb) {
          return 1 / ((1 - q) * ttc(b,c) / ntg(b,c) + q) * ttc(b,c);
        } else {
          return ttc(b,c);
        }
      };
      rstc.referenceCar = this.computeReferenceCar();
      return rstc;
    }

    function ChangingRstc(rstc) {
      this.rstc = rstc;
      this.cars = this.rstc.cars;
      this.computeReferenceCar = function () { this.referenceCar = this.rstc.computeReferenceCar(); return this.referenceCar; };
      this.forceReferenceCar = function (b) { this.rstc.forceReferenceCar(b); };
      this.progress = function () { this.rstc = this.rstc.progress(); return this; };
      this.wait = function (t) { this.rstc = this.rstc.wait(t); return this; };
      this.accel = function (b, q) { this.rstc = this.rstc.accel(b, q); return this; };
      this.ntg = function (b, c) { return this.rstc.ntg(b, c); };
      this.ttc = function (b, c) { return this.rstc.ttc(b, c); };
      this.x = function (b, c) { return this.rstc.x(b, c); };
      this.v = function (b) { return this.rstc.v(b); };
      this.time = function (t) { return this.rstc.time(t); };
    }

    function InterpolatingRstc(obs) {
      var now = obs[0].time;
      this.cars = obs[0].rstc.cars;
      this.computeReferenceCar = function () {
        var ref = obs[0].rstc.computeReferenceCar();
        for (var i = 1; i < obs.length; ++i) {
          obs[i].rstc.forceReferenceCar(ref);
        }
        return ref;
      };
      this.forceReferenceCar = function (b) {
        for (var i = 0; i < obs.length; ++i) {
          obs[i].rstc.forceReferenceCar(b);
        }
      };
      this.wait = function (t) { now += t; };
      /*this.accel = function (b, q) { ; };*/
      this.ntg = function (b, c) {
        for (var i = 0; i < obs.length; ++i) {
          if (now >= obs[i].time) {
            if (i+1 < obs.length && now < obs[i+1].time) {
              var r0 = obs[i].rstc;
              var r1 = obs[i+1].rstc;
              var len = obs[i+1].time - obs[i].time;
              var rel = now - obs[i].time;
              return r0.ntg(b, c) + rel / len * (r1.ntg(b, c) - r0.ntg(b, c));
            } else if (i+1 == obs.length) {
              return obs[i].rstc.wait(now - obs[i].time).ntg(b, c);
            }
          }
        }
      };
      this.ttc = function (b, c) {
        for (var i = 0; i < obs.length; ++i) {
          if (now >= obs[i].time) {
            if (i+1 < obs.length && now < obs[i+1].time) {
              var r0 = obs[i].rstc;
              var r1 = obs[i+1].rstc;
              var len = obs[i+1].time - obs[i].time;
              var rel = now - obs[i].time;
              return r0.ttc(b, c) + rel / len * (r1.ttc(b, c) - r0.ttc(b, c));
            } else if (i+1 == obs.length) {
              return obs[i].rstc.wait(now - obs[i].time).ttc(b, c);
            }
          }
        }
      };
      this.v = Rstc.prototype.v;
      this.x = Rstc.prototype.x;
      this.time = function (t) { if (t != undefined) now = t; return now; };
    }

    var DEFAULT_FPS = 50;

    /* Street object. Utility object for my animations. */
    function Street(streetId, timer, lanes, extra) {
      if (extra == undefined) {
        extra = { };
      }
      if (extra.offset == undefined) {
        extra.offset = 0;
      }
      if (extra.offsetTop == undefined) {
        extra.offsetTop = extra.offset;
      }
      if (extra.offsetBottom == undefined) {
        extra.offsetBottom = extra.offset;
      }
      if (extra.lines == undefined) {
        extra.lines = 0;
      }
      if (extra.linesTop == undefined) {
        extra.linesTop = extra.lines;
      }
      if (extra.linesBottom == undefined) {
        extra.linesBottom = extra.lines;
      }
      if (extra.textHeight == undefined) {
        extra.textHeight = bodyFontSizeInPixel();
      }
      if (extra.fps == undefined) {
        extra.fps = DEFAULT_FPS;
      }
      if (extra.relWidth == undefined) {
        extra.relWidth = 1.0;
      }
      if (extra.relHeight == undefined) {
        extra.relHeight = 1.0;
      }

      var WIDTH_TO_HEIGHT = 14 / lanes / extra.relHeight;
      var LINE_SPACING = 0.2;
      var elem = document.getElementById(streetId);
      var canvas = document.createElement("canvas");
      canvas.setAttribute("width", "100%");
      elem.appendChild(canvas);
      var ctx = this.ctx = canvas.getContext("2d");
      var streetWidth = extra.relWidth * window.innerWidth * 0.95;
      var streetHeight = Math.min(window.innerHeight, streetWidth / WIDTH_TO_HEIGHT);

      extra.offsetTop = sizeToPixel(extra.offsetTop, streetHeight);
      extra.offsetBottom = sizeToPixel(extra.offsetBottom, streetHeight);
      extra.textHeight = sizeToPixel(extra.textHeight, bodyFontSizeInPixel());

      var pavementTopHeight = extra.offsetTop + extra.linesTop * extra.textHeight * (1 + LINE_SPACING);
      var pavementBottomHeight = extra.offsetBottom + extra.linesBottom * extra.textHeight * (1 + LINE_SPACING);
      ctx.canvas.width = streetWidth;
      ctx.canvas.height = streetHeight + pavementTopHeight + pavementBottomHeight;

      var markHeight = streetHeight / (10 * lanes);
      var markWidth = streetWidth / 20;

      this.timer = function () { return timer; };
      this.streetWidth = function () { return streetWidth; };
      this.streetHeight = function () { return streetHeight; };
      this.offsetTop = function () { return extra.offsetTop; };
      this.offsetBottom = function () { return extra.offsetBottom; };
      this.pavementTopHeight = function () { return pavementTopHeight; };
      this.pavementBottomHeight = function () { return pavementBottomHeight; };
      this.laneHeight = function () { return (streetHeight - markHeight) / lanes; };
      this.textHeight = function () { return extra.textHeight; };

      var markRelOffset = 0;
      this.scroll = function (rel) { markRelOffset = rel; };

      this.x = function (xRel) {
        return xRel * streetWidth;
      };
      this.y = function (yRel) {
        return pavementTopHeight + (-yRel + Math.floor(lanes / 2)) * streetHeight / lanes + streetHeight / lanes / 2;
      };
      this.textY = function (top, line) {
        var y0 = pavementTopHeight + (top ? -1 * extra.offsetTop : streetHeight + extra.offsetBottom);
        var y1 = (top ? -1 : 1) * (line + (top ? 0 : 1)) * extra.textHeight * (1 + LINE_SPACING);
        var y2 = -1 * LINE_SPACING * extra.textHeight;
        return y0 + y1 + y2;
      };

      var redrawHooks = {};
      var redrawHookId = 0;
      this.addRedrawHook = function (hook) { redrawHooks[++redrawHookId] = hook; return redrawHookId; };
      this.removeRedrawHook = function (id) { delete redrawHooks[id]; };

      function redraw() {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, streetWidth, pavementTopHeight);
        ctx.fillRect(0, pavementTopHeight+streetHeight, streetWidth, pavementBottomHeight);

        ctx.fillStyle = "#999999";
        ctx.fillRect(0, pavementTopHeight, streetWidth, streetHeight);

        var markOffset = markWidth / 2 + markRelOffset * streetWidth;
        if (Math.abs(markOffset) > 2 * markWidth) {
          markOffset = markOffset % (2 * markWidth);
        }
        for (var i = 0; i < lanes - 1; ++i) {
          var markYPos = pavementTopHeight + (i + 1) * streetHeight / lanes - markHeight / 2;
          for (var x = markOffset; x < streetWidth; x += 2 * markWidth) {
            ctx.fillStyle = "white";
            ctx.fillRect(x, markYPos, markWidth, markHeight);
          }
        }

        for (var id in redrawHooks) {
          redrawHooks[id](timer.secs());
        }

        timer.addEvent(redraw, 1 / extra.fps);
      }

      redraw();
    }


    /* A image moving along the street. 
     * For cars, the height and width params can be left undefined. */
    function Elem(id, img, street, xf, yf, extra) {
      if (extra == undefined) {
        extra = {};
      }
      if (extra.radf == undefined) {
        extra.radf = function () { return 0; };
      }
      if (extra.height == undefined) {
        extra.height = street.laneHeight() * 0.75;
      }
      if (extra.width == undefined) {
        extra.width = extra.height * 2;
      }

      var elem = document.getElementById(img);
      this.id = id;
      this.xf = xf;
      this.yf = yf;
      this.radf = extra.radf;
      this.width = extra.width;
      this.height = extra.height;

      var self = this;
      var i = street.addRedrawHook(function (t) {
        street.ctx.save();
        street.ctx.translate(street.x(self.xf(t)), street.y(self.yf(t)));
        street.ctx.rotate(self.radf(t));
        street.ctx.drawImage(elem, -self.width/2, -self.height/2, self.width, self.height);
        street.ctx.restore();
      });

      if (extra.timeout != undefined) {
        street.timer().addEvent(function () { street.removeRedrawHook(i); }, extra.timeout);
      }
    }

    var LINE_WIDTH = 5;
    var ARROW_WIDTH = 3.5;

    function RstcVis(rstc, carMap, street, ms, extra) {
      if (extra == undefined) {
        extra = {};
      }
      if (extra.color == undefined) {
        extra.color = "#000000";
      }
      if (extra.line == undefined) {
        extra.line = 0;
      }
      if (extra.arrowWidth == undefined) {
        extra.arrowWidth = 10;
      }
      if (extra.arrowStumpOffset == undefined) {
        extra.arrowStumpOffset = 0;
      }
      if (extra.arrowHeadOffset == undefined) {
        extra.arrowHeadOffset = 0;
      }
      if (extra.filledArrow == undefined) {
        extra.filledArrow = true;
      }
      if (extra.shadow == undefined) {
        extra.shadow = true;
      }
      this.i = undefined;
      function drawEdge(t, b, c, top) {
        if (top == undefined) {
          top = true;
        }
        var offsetY = (top ? -1 : 1) * 5;
        var x1 = street.x(b.xf(t)) + extra.arrowStumpOffset;
        var y1 = street.y(b.yf(t)) + offsetY;
        var x2 = street.x(c.xf(t)) + extra.arrowHeadOffset;
        var y2 = street.y(c.yf(t)) + offsetY;
        var ctrl = top
          ? street.pavementTopHeight() - street.offsetTop()
          : street.pavementTopHeight() + street.streetHeight() + street.offsetBottom();
        street.ctx.save();
        street.ctx.strokeStyle = extra.color;
        street.ctx.lineWidth = LINE_WIDTH;
        street.ctx.beginPath();
        street.ctx.moveTo(x1, y1);
        street.ctx.bezierCurveTo(x1, ctrl, x2, ctrl, x2, y2);
        street.ctx.stroke();
        if (!extra.filledArrow) {
          street.ctx.lineWidth = ARROW_WIDTH;
          street.ctx.strokeStyle = extra.color;
          street.ctx.moveTo(x2, y2);
          street.ctx.lineTo(x2 - extra.arrowWidth, y2 + (top ? -1 : 1) * extra.arrowWidth);
          street.ctx.moveTo(x2, y2);
          street.ctx.lineTo(x2 + extra.arrowWidth, y2 + (top ? -1 : 1) * extra.arrowWidth);
          street.ctx.stroke();
        } else {
          street.ctx.beginPath();
          street.ctx.fillStyle = extra.color;
          street.ctx.moveTo(x2, y2 + (top ? 3 : -3));
          street.ctx.lineTo(x2 - extra.arrowWidth, y2 + (top ? -1 : 1) * extra.arrowWidth);
          street.ctx.lineTo(x2 + extra.arrowWidth, y2 + (top ? -1 : 1) * extra.arrowWidth);
          street.ctx.closePath();
          street.ctx.fill();
        }
        if (street.textHeight() > 0) {
          var ntgStr = "NTG = "+ rstc.ntg(b.id, c.id).toFixed(1) +" s";
          var ttcStr = "TTC = "+ rstc.ttc(b.id, c.id).toFixed(1) +" s";
          street.ctx.font = "bold "+ street.textHeight() +"px sans-serif";
          var str = ntgStr +", "+ ttcStr;
          var width = street.ctx.measureText(str).width;
          var textX = x1 + (x2-x1) / 2 - width / 2;
          var textY = street.textY(top, extra.line);
          //street.ctx.fillStyle = "#333333";
          //street.ctx.fillText(ntgStr +", "+ ttcStr, textX + 2, textY + 2);
          street.ctx.fillStyle = extra.color;
          street.ctx.fillText(str, textX, textY);
          if (extra.shadow) {
            street.ctx.strokeStyle = "#333333";
            street.ctx.lineWidth = 1;
            street.ctx.strokeText(str, textX, textY);
          }
        }
        street.ctx.restore();
      }
      function draw(t) {
        var m = typeof ms == "function" ? ms(t) : ms;
        for (var b in m) {
          var bb = carMap[b];
          for (var c in m[b]) {
            var cc = carMap[c];
            if (b != c) {
              drawEdge(t, bb, cc, b < c);
            }
          }
        }
      }
      this.enable = function () { if (this.i == undefined) { this.i = street.addRedrawHook(draw); } };
      this.disable = function () { if (this.i != undefined) { street.removeRedrawHook(this.i); this.i = undefined; } };
    }

    function addS(data, b, ms) {
      if (ms == undefined) {
        ms = b;
      }
      if (b[0]) {
        for (var i = 0; i < b.length; ++i) {
          data[b[i].id] = ms[i];
        }
      } else {
        data[b.id] = ms;
      }
      return data;
    }

    function addM(data, from, to, ms) {
      if (ms == undefined) {
        ms = true;
      }
      if (data[from.id] == undefined) {
        data[from.id] = {};
      }
      data[from.id][to.id] = ms;
      return data;
    }

    function addAccelSymbol(street, b, accel, timeout) {
      if (accel >= 1) {
        var flameHeight = 0.5 * street.laneHeight();
        var flameWidth = 2 * flameHeight;
        var flame = new Elem("flame", "flame", street,
          function (t) { return b.xf(t) - (b.width + flame.width) / street.streetWidth() / 2; },
          function (t) { return b.yf(t); },
          { width: flameWidth
          , height: flameHeight
          , timeout: (timeout != undefined ? timeout : Math.abs(accel - 1) * 3) }
        );
        /*
        var dustHeight = 0.5 * street.laneHeight();
        var dustWidth = dustHeight;
        var dust = new Elem("cloud", "cloud", street,
          function (t) { return b.xf(t) - (b.width + dust.width) / street.streetWidth() / 2; },
          function (t) { return b.yf(t); },
          { width: dustWidth
          , height: dustHeight
          , timeout: (timeout != undefined ? timeout : Math.abs(accel - 1) * 3) }
        );
        dustHeight *= 0.5;
        dustWidth *= 0.5;
        var smallDust = new Elem("cloud", "cloud", street,
          function (t) { return b.xf(t) - (b.width / 2 + smallDust.width / 2 + dust.width) / street.streetWidth(); },
          function (t) { return b.yf(t); },
          { width: dustWidth
          , height: dustHeight
          , timeout: (timeout != undefined ? timeout : Math.abs(accel - 1) * 3) }
        );
        */
      } else {
        var parachuteAspectRatio = 431 / 289;
        var parachuteHeight = 0.65 * street.laneHeight();
        var parachuteWidth = parachuteHeight * parachuteAspectRatio;
        var parachute = new Elem("parachute", "parachute", street,
          function (t) { return b.xf(t) - (b.width + parachute.width) / 2 / street.streetWidth(); },
          function (t) { return b.yf(t); },
          { width: parachuteWidth, height: parachuteHeight
          , timeout: (timeout != undefined ? timeout : Math.abs(accel - 1) * 10) }
        );
        /*
        var skidMarks = new Elem("skid-marks", "skid-marks", street,
          function (t) { return b.xf(t) - (b.width + skidMarks.width) / 2 / street.streetWidth(); },
          function (t) { return b.yf(t); },
          { width: Math.abs(accel - 1) * 0.2 * street.streetWidth()
          , timeout: (timeout != undefined ? timeout : Math.abs(accel - 1) * 10) }
        );
        */
      }
    }

    function addActionToSit(sit, rstc, name, args, extra) {
      if (extra == undefined) {
        extra = {};
      }
      if (extra.carToColor == undefined) {
        extra.carToColor = function () { return undefined; }
      }
      if (extra.stepInPixels == undefined) {
        extra.stepInPixels = 5;
      }
      if (extra.stepDuration == undefined) {
        extra.stepDuration = 30;
      }
      if (extra.precision == undefined) {
        extra.precision = 1;
      }

      if (name == "wait" && args == undefined) {
        args = [ "<div class=\"wait-action-timestamp\">"+ rstc.time().toFixed(extra.precision) +"</div>" ];
      }
      var act = document.createElement("div");
      var str = name;
      if (args != undefined) {
        str += "(";
        for (var i = 0; i < args.length; ++i) {
          if (i > 0) {
            str += ", ";
          }
          if (typeof args[i] === "number") {
            str += args[i].toFixed(extra.precision);
          } else if (typeof args[i] === "string") {
            var color = extra.carToColor(args[i]);
            if (color != undefined) {
              str += "<span style=\"color: "+ color +";\">"+ args[i] +"</span>";
            } else {
              str += args[i];
            }
          } else {
            str += args[i];
          }
        }
        str += ")";
      }
      act.innerHTML = str;
      act.className = "action";
      sit.insertBefore(act, sit.firstChild);
      var invisiblePos = -1 * act.offsetWidth;
      act.style.marginLeft = invisiblePos +"px";
      act.style.visibility = "hidden";
      var sliderIntervalId = setInterval(function () {
        // when another action is already sliding in, we wait for it being completely slided in
        if (!act.nextSibling || (act.nextSibling.style && act.nextSibling.style.marginLeft && parseInt(act.nextSibling.style.marginLeft.replace(/[^-0-9]/g, "")) >= 0)) {
          clearInterval(sliderIntervalId);
          act.style.visibility = "visible";
          slideElement(act, invisiblePos, 0, extra.stepInPixels, extra.stepDuration);
        }
      }, 50);
    }

    function updateTimeInSit(sit, rstc) {
      for (var actionNode = sit.firstChild; actionNode; actionNode = actionNode.nextSibling) {
        for (var timeStampNode = actionNode.firstChild; timeStampNode; timeStampNode = timeStampNode.nextSibling) {
          if (timeStampNode.className == "wait-action-timestamp") {
            timeStampNode.innerHTML = rstc.time().toFixed(1);
            return;
          }
        }
      }
    }

    function slideElement(elem, from, to, steps, speed) {
      var slideDist = Math.abs(to - from);
      var id = setInterval(function () {
        var steps1 = undefined;
        if (typeof steps == "function") {
          var slideDone = Math.abs(to - from);
          steps1 = steps(slideDone / slideDist);
        } else {
          steps1 = steps;
        }
        if (from < to && from+steps1 >= to || from > to && from+steps1 <= to) {
          from = to;
        } else {
          from += steps1;
        }
        elem.style.marginLeft = from +"px";
        if (from == to) {
          clearInterval(id);
        }
      }, speed);
      return id;
    }

    function appearElement(elem, i, steps, speed) {
      i = i || 0;
      steps = steps || 5;
      speed = speed || 50;
      var t_o = setInterval(function () {
        var opacity = i / 100;
        i = i + steps;
        if (opacity > 1 || opacity < 0) {
          clearInterval(t_o);
          return;
        }
        elem.style.opacity = opacity;
        elem.style.filter = 'alpha(opacity=' + opacity*100 + ')';
      }, speed);
    }

    function sizeToPixel(str, relative) {
      if (typeof str == "string") {
        if (str.indexOf("px") != -1) {
          return parseInt(str.replace(/[^-0-9]/g, ""));
        } else if (str.indexOf("pt") != -1) {
          return 96 / 72 * parseInt(str.replace(/[^-0-9]/g, ""));
        } else if (str.indexOf("%") != -1) {
          return relative * parseFloat(str.replace(/[^-0-9]/g, "")) / 100;
        } else {
          return parseFloat(str);
        }
      } else {
        return str;
      }
    }

    function bodyFontSizeInPixel() {
      var fontSize = document.body.style.fontSize;
      if (fontSize != undefined &&
          typeof fontSize == "string" &&
          fontSize.length > 0) {
        return sizeToPixel(fontSize, 18);
      } else {
        return 18;
      }
    }

    var jaxMap = {};
    var boxMap = {};

    function renderTeX(tex, elemId, boxId) {
      if (box == undefined) {
        boxId = elemId;
      }

      var math = null;
      var box = null;

      //  Hide and show the box (so it doesn't flicker as much)
      function hidebox () { box.style.visibility = "hidden"; }
      function showbox () { box.style.visibility = "visible"; }

      // Get the element jax when MathJax has produced it.
      if (jaxMap[elemId] && boxMap[boxId]) {
        math = jaxMap[elemId];
        box = boxMap[boxId];
      } else {
        if (window.MathJax == undefined) {
          return false; // failure
        }
        MathJax.Hub.queue.Push(function () {
          math = MathJax.Hub.getAllJax(elemId)[0];
          box = document.getElementById(boxId);
          jaxMap[elemId] = math;
          boxMap[boxId] = box;
          showbox(); // box is initially hidden so the braces don't show
        });
      }

      if (math == undefined || box == undefined) {
        return false; // failure
      }
      MathJax.Hub.queue.Push(hidebox, ["Text", math, "\\displaystyle{"+tex+"}"], showbox);
      return true;
    }

    function repeatForSuccess(f, t) {
      if (t == undefined) {
        t = 100;
      }
      var id = setInterval(function () {
        if (f()) {
          clearInterval(id);
        }
      }, t);
    }

    var GET_PARAMS = {};

    window.onload = function () {
      var prmstr = window.location.search.substr(1);
      var prmarr = prmstr.split ("&");

      for (var i = 0; i < prmarr.length; i++) {
        var tmparr = prmarr[i].split("=");
        GET_PARAMS[tmparr[0]] = tmparr[1];
      }

      var fps = GET_PARAMS["fps"];
      if (fps != undefined) {
        fps = parseInt(fps);
        if (!isNaN(fps)) {
          DEFAULT_FPS = fps;
        }
      }

      /* Additionally for MathJax scaling see texScale(). */
      if (window.innerHeight <= 864 || window.innerWidth <= 1152) {
      //if (window.innerHeight <= 800 || window.innerWidth <= 1024) {
        console.log("Hardcoded slidy resize (smaller) due to resolution.");
        w3c_slidy.smaller();
        --LINE_WIDTH;
        --ARROW_WIDTH;
      }
      if (window.innerHeight <= 600 || window.innerWidth <= 800) {
        console.log("Hardcoded slidy resize (smaller) due to resolution.");
        w3c_slidy.smaller();
        --LINE_WIDTH;
        ARROW_WIDTH = Math.min(ARROW_WIDTH, LINE_WIDTH);
      }
      if (window.innerHeight <= 480 || window.innerWidth <= 640) {
        console.log("Hardcoded slidy resize (smaller) due to resolution.");
        w3c_slidy.smaller();
        --LINE_WIDTH;
        ARROW_WIDTH = Math.min(ARROW_WIDTH, LINE_WIDTH);
      }

      if (GET_PARAMS["scrollbars"] != "enable") {
        var bodies = document.getElementsByTagName("body");
        for (var i = 0; i < bodies.length; ++i) {
          bodies[i].style.overflow = "hidden";
        }
      }

      /* Hacky: We first try to load a local copy of MathJax and wait some
       * seconds to load it from remote, if the local copy is not available. */
      loadMathJaxIfNecessary("MathJax");
      setTimeout(loadRemoteMathJaxIfNecessary, 3 * 1000);

      /* It looks best under Chrome. Especially IE looks bad. */
      if (navigator.userAgent.indexOf("Chrome") == -1) {
        var browserPrompt = document.createElement("div");
        browserPrompt.style.position = "absolute";
        browserPrompt.style.width = "50%";
        browserPrompt.style.left = "25%";
        browserPrompt.style.top = "10%";
        browserPrompt.style.backgroundColor = "orange";
        browserPrompt.style.borderWidth = "thick";
        browserPrompt.style.borderColor = "black";
        browserPrompt.style.borderStyle = "solid";
        browserPrompt.style.overflow = "auto";
        browserPrompt.style.zIndex = "99";

        browserPrompt.innerHTML = "<p style=\"text-align: center;\">These slides look best under Chrome.<\/p>";

        document.body.appendChild(browserPrompt);

        setTimeout(function () { document.body.removeChild(browserPrompt); }, 2500);

        browserPrompt.addEventListener("click", function (e) {
          document.body.removeChild(browserPrompt);
          if (e.cancel != undefined)
            e.cancel = true;
          if (e.returnValue != undefined)
            e.returnValue = false;
          e.stopPropagation();
        }, false);
      }

      /* Link to paper. */
      var linkToPaper = true;
      if (linkToPaper) {
        var paperPrompt = document.createElement("div");
        paperPrompt.style.position = "absolute";
        paperPrompt.style.width = "50%";
        paperPrompt.style.left = "25%";
        paperPrompt.style.top = "25%";
        paperPrompt.style.backgroundColor = "blue";
        paperPrompt.style.borderWidth = "thick";
        paperPrompt.style.borderColor = "black";
        paperPrompt.style.borderStyle = "solid";
        paperPrompt.style.overflow = "auto";
        paperPrompt.style.zIndex = "99";

        paperPrompt.innerHTML = "<p style=\"text-align: center;\">The <a href=\"https://schwering.github.io/commonsense-2013.pdf\">paper is available here:<br /><code>https://schwering.github.io/commonsense-2013.pdf</code></a><br />But the slides may be more accessible.<\/p>";

        document.body.appendChild(paperPrompt);

        setTimeout(function () { document.body.removeChild(paperPrompt); }, 5000);

        paperPrompt.addEventListener("click", function (e) {
          document.body.removeChild(paperPrompt);
          if (e.cancel != undefined)
            e.cancel = true;
          if (e.returnValue != undefined)
            e.returnValue = false;
          e.stopPropagation();
        }, false);
      }
    };

  </script>
</head>
<body>

  <div style="display: none;">
    $
    \DeclareMathOperator{\DOT}{.}
    \DeclareMathOperator{\nondet}{|}
    \newcommand\conc{\parallel}
    \newcommand\m[1]{\mathit{#1}}
    \newcommand\D{\mathcal{D}}
    \newcommand\E{\mathcal{E}}
    \newcommand\F{\mathcal{F}}
    \newcommand\I{\mathfrak{I}}
    \newcommand\ntg{\m{ntg}}
    \newcommand\ttc{\m{ttc}}
    \newcommand\tntg{\m{tntg}}
    \newcommand\tttc{\m{tttc}}
    \newcommand\antg{\m{antg}}
    \newcommand\attc{\m{attc}}
    \newcommand\NTG{\m{NTG}}
    \newcommand\TTC{\m{TTC}}
    \newcommand\TNTG{\m{TNTG}}
    \newcommand\TTTC{\m{TTTC}}
    \newcommand\nonzero{\eta}
    \newcommand\defined{\kappa}
    \newcommand{\defeq}{\stackrel{\mathsf{def}}{=}}
    \newcommand{\qqquad}{\quad\qquad}
    \newcommand\b{\color{blue}b}
    \newcommand\c{\color{red}c}
    \newcommand\d{\color{green}d}
    $
  </div>


<!--
<div class="background">
  <object id="logo-left" data="graphics/kbsg-logo-original.svg" type="image/svg+xml" title="KBSG">
    <img alt="KBSG" id="logo-left-fallback" src="graphics/kbsg-logo.png" />
  </object>
  <object id="logo-right" data="graphics/rwth-logo.svg" type="image/svg+xml" title="RWTH">
    <img alt="RWTH" id="logo-right-fallback" src="graphics/rwth-logo.jpg" />
  </object>
</div>
-->


<div class="slide cover title">
  <!-- hidden style graphics to ensure they are saved with other content -->
  <img class="hidden" id="car-aqua" src="graphics/car-aqua.svg" alt="" />
  <img class="hidden" id="car-blue" src="graphics/car-blue.svg" alt="" />
  <img class="hidden" id="car-green" src="graphics/car-green.svg" alt="" />
  <img class="hidden" id="car-lightblue" src="graphics/car-lightblue.svg" alt="" />
  <img class="hidden" id="car-lime" src="graphics/car-lime.svg" alt="" />
  <img class="hidden" id="car-maroon" src="graphics/car-maroon.svg" alt="" />
  <img class="hidden" id="car-pink" src="graphics/car-pink.svg" alt="" />
  <img class="hidden" id="car-purple" src="graphics/car-purple.svg" alt="" />
  <img class="hidden" id="car-red" src="graphics/car-red.svg" alt="" />
  <img class="hidden" id="car-white" src="graphics/car-white.svg" alt="" />
  <img class="hidden" id="car-yellow" src="graphics/car-yellow.svg" alt="" />
  <img class="hidden" id="skid-marks" src="graphics/skid-marks.svg" alt="" />
  <img class="hidden" id="parachute" src="graphics/parachute.svg" alt="" />
  <img class="hidden" id="tree" src="graphics/tree.svg" alt="" />
  <img class="hidden" id="left-arrow" src="graphics/left-arrow.svg" alt="" />
  <img class="hidden" id="sign-frog" src="graphics/sign-frog.svg" alt="" />
  <img class="hidden" id="cloud" src="graphics/gray-cloud.svg" alt="" />
  <img class="hidden" id="flame" src="graphics/flame.svg" alt="" />
  <img class="hidden" id="finch" src="graphics/finch.png" alt="" />
  <img class="hidden" id="frog" src="graphics/frog.svg" alt="" />
  <img class="hidden" src="graphics/torcs.png" alt="" />
  <img class="hidden" src="graphics/blue-question-mark.png" alt="" />
  <img class="hidden" src="graphics/green-check-mark.png" alt="" />
  <img class="hidden" src="graphics/red-cross.png" alt="" />
  <img class="hidden" src="graphics/bullet.png" alt="" />
  <img class="hidden" src="graphics/fold.gif" alt="" />
  <img class="hidden" src="graphics/unfold.gif" alt="" />
  <img class="hidden" src="graphics/fold-dim.gif" alt="" />
  <img class="hidden" src="graphics/nofold-dim.gif" alt="" />
  <img class="hidden" src="graphics/unfold-dim.gif" alt="" />
  <img class="hidden" src="graphics/bullet-fold.gif" alt="" />
  <img class="hidden" src="graphics/bullet-unfold.gif" alt="" />
  <img class="hidden" src="graphics/bullet-fold-dim.gif" alt="" />
  <img class="hidden" src="graphics/bullet-nofold-dim.gif" alt="" />
  <img class="hidden" src="graphics/bullet-unfold-dim.gif" alt="" />

  <h1><span class="avoid-break">Spatio-Temporal&nbsp;Reasoning about Traffic&nbsp;Scenarios</span></h1>

  <div class="author-info">
    <ul class="authors no-bullet">
      <li style="padding-right: 3em;"><a href="mailto:schwering@kbsg.rwth-aachen.de">Christoph Schwering</a></li>
      <li style="padding-left: 3em;"><a href="mailto:gerhard@kbsg.rwth-aachen.de">Gerhard Lakemeyer</a></li>
    </ul>

    <div class="affiliation">
      <div class="chair">
        <p>Knowledge-Based Systems Group</p>
        <object data="graphics/kbsg-logo.svg" type="image/svg+xml" title="KBSG">
          <img alt="KBSG" src="graphics/kbsg-logo.png" />
        </object>
      </div>

      <div class="university">
        <p>RWTH Aachen University</p>
        <object data="graphics/rwth-logo-inverted.svg" type="image/svg+xml" title="RWTH">
          <img alt="RWTH" src="graphics/rwth-logo.jpg" />
        </object>
      </div>
    </div>
  </div>

  <p class="occasion">Commonsense 2013</p>
</div>


<div class="slide" id="intro-slide">
  <h1>Introduction</h1>
  <div class="vcenter hcenter">
    <div id="intro-street" class="street no-print"></div>
    <ul>
      <li>Longitudinal traffic model
      <ul>
        <li>Continuous values</li>
        <li>Relative perspective</li>
        <li>Complete view of traffic</li>
      </ul>
      </li>
      <li>Based on <em>temporal</em> distance measures
      <ul>
        <li>Net Time Gap (NTG)</li>
        <li>Time To Collision (TTC)</li>
      </ul>
      </li>
      <li>Application in plan recognition</li>
    </ul>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetId = "intro-street";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren(streetId);
      }

      function run() {
        timer = new Timer();
        var street = new Street(streetId, timer, 2, { offset: "25%", fps: 10, relWidth: 0.5 });

        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return 1; }
        );

        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; }
        );

        var d = new Elem("d", "car-green", street,
          function (t) { return pos(d.id); },
          function (t) { return 1; }
        );

        var rstc = new Rstc(addM(addM({}, b, c, {ntg: -1.5,  ttc: -15}), c, d, {ntg: -3,  ttc: -40}));
        function pos(car) {
          return SCALE * rstc.x(car) + 0.6;
        }
      }

      addSlideInitializer("intro-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("intro-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="ntg-slide">
  <h1>Net Time Gap (NTG)</h1>
  <div class="vcenter">
    <div id="ntg-street" class="street no-print"></div>
    <div style="text-align: center; width: 100%;">Net Time Gap: &nbsp;&nbsp;&nbsp;
      ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) =
      <div style="min-width: 2em; text-align: right; display: inline-block;" id="ntg-msg"></div> s
    </div>
    <p style="text-align: center; margin-left: auto; margin-right: auto;">$\ntg(\b,\c) = \frac{x(\c) - x(\b)}{v(\b)}$</p>
  </div>
  <div id="ntg-slide-show-continuous" class="incremental no-print" style="display: none;"></div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetId = "ntg-street";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren([streetId]);
      }

      function run(continuous) {
        timer = new Timer();
        var street = new Street(streetId, timer, 2, { offsetBottom: "50%" });

        var msgBox = document.getElementById("ntg-msg");
        msgBox.innerHTML = "...";

        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return 1; }
        );

        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; }
        );

        var rstc = new ChangingRstc(new Rstc(addM({}, c, b, {ntg:-4.5, ttc:30})));
        rstc.forceReferenceCar(c.id);
        rstc = rstc.wait(0);

        function pos(car) {
          var refpos = 0.5;
          return SCALE * rstc.x(car) + refpos;
        }

        var treesTurn = true;
        var pOffset = 1;

        // Time of car b and c when it pass the tree, respectively.
        var t0 = undefined;
        var t1 = undefined;

        var treeAspectRatio = 439 / 597;
        var tree = new Elem("tree", "tree", street,
          function (t) {
            if (!continuous) {
              if (!treesTurn) {
                return -1;
              }
              var p = 1 - t * SCALE + pOffset;
              if (t0 == undefined && pos(c.id) >= p) { t0 = t; }
              if (t1 == undefined && pos(b.id) >= p) { t1 = t; }
              if (t0 != undefined || t1 != undefined) {
                var tDiff = (t1 != undefined ? t1 : t) - (t0 != undefined ? t0 : t);
                msgBox.innerHTML = tDiff.toFixed(1);
              }
              if (p <= -0.05) {
                pOffset += 1.1 - p;
                //treesTurn = false;
              }
              if (t0 != undefined && t1 != undefined && 0.9 < p && p < 1.0) {
                msgBox.innerHTML = "...";
                t0 = undefined;
                t1 = undefined;
              }
              return p;
            } else {
              return -1;
            }
          },
          function (t) { return 0; },
          { width: 2.5 * street.laneHeight() * treeAspectRatio
          , height: 2.5 * street.laneHeight() }
        );

        /*
        var signFrogAspectRatio = 358 / 985;
        var signFrogOccurred = 0;
        var signFrog = new Elem("sign-frog", "sign-frog", street,
          function (t) {
            if (!continuous) {
              if (treesTurn) {
                return -1;
              }
              var p = 1 - t * SCALE + pOffset;
              if (t0 == undefined && pos(c.id) >= p) { t0 = t; }
              if (t1 == undefined && pos(b.id) >= p) { t1 = t; }
              if (t0 != undefined || t1 != undefined) {
                var tDiff = (t1 != undefined ? t1 : t) - (t0 != undefined ? t0 : t);
                msgBox.innerHTML = tDiff.toFixed(1);
              }
              if (p <= -0.05) {
                pOffset += 1.1 - p;
                treesTurn = true;
                ++signFrogOccurred;
              }
              if (p <= 0.2) {
                frogEnabled = true && signFrogOccurred >= 1;
              }
              if (t0 != undefined && t1 != undefined && 0.9 < p && p < 1.0) {
                msgBox.innerHTML = "...";
                t0 = undefined;
                t1 = undefined;
              }
              return p;
            } else {
              return -1;
            }
          },
          function (t) { return 0; },
          { width: 2.5 * street.laneHeight() * signFrogAspectRatio,
          , height: 2.5 * street.laneHeight() }
        );

        var frogEnabled = false;
        */
        /*
        var frogAspectRatio = 290 / 190;
        var tFrogOffset = 0;
        var jump = 0;
        var frog = new Elem("frog", "frog", street,
          function (t) {
            if (!frogEnabled) {
              jump = 0;
              tFrogOffset = t;
              return -1;
            }
            var p = 0.2 * (t - tFrogOffset) * SCALE + 0.05;
            var JUMP_FACTOR = 1.01;
            if (jump < 50) {
              frog.width *= JUMP_FACTOR;
              frog.height *= JUMP_FACTOR;
              } else {
              frog.width /= JUMP_FACTOR;
              frog.height /= JUMP_FACTOR;
            }
            jump = (jump + 1) % 100;
            if (p >= 1) {
              frogEnabled = false;
            }
            return p;
          },
          function (t) { return 3 * (t - tFrogOffset) * SCALE - 1.5; },
          { width: 0.5 * street.laneHeight() * frogAspectRatio
          , height: 0.5 * street.laneHeight() }
        );
        */

        street.addRedrawHook(function (t) {
          street.scroll(-1 * t * SCALE);
          rstc.time(t);
          if (pos(b.id) >= 1.05) {
            clear();
            run(continuous);
          } else if (continuous) {
            msgBox.innerHTML = rstc.ntg(b.id, c.id).toFixed(1);
          }
        });

        setNodeInitializer("ntg-slide-show-continuous", function (node) { continuous = true; });
        setNodeFinalizer("ntg-slide-show-continuous", function (node) { msgBox.innerHTML = "..."; continuous = false; });
      }

      addSlideInitializer("ntg-slide", function (slide) { clear(); run(false); });
      addSlideFinalizer("ntg-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="ttc-slide">
  <h1>Time To Collision (TTC)</h1>
  <div class="vcenter">
    <div id="ttc-street" class="street no-print"></div>
    <div style="text-align: center; width: 100%;">Time To Collision: &nbsp;&nbsp;&nbsp;
      ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) =
      <div style="min-width: 2em; text-align: right; display: inline-block;" id="ttc-msg"></div> s
    </div>
    <p style="text-align: center; margin-left: auto; margin-right: auto;">$\ttc(\b,\c) = \frac{x(\c) - x(\b)}{v(\b) - v(\c)}$</p>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetId = "ttc-street";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren([streetId]);
      }

      function run() {
        timer = new Timer();
        var street = new Street(streetId, timer, 2, { linesTop: 0, linesBottom : 2 });

        var msgBox = document.getElementById("ttc-msg");
        msgBox.innerHTML = "...";

        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return 1; } //Math.sin(t * Math.PI) / 4; }
        );

        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; }
        );

        street.addRedrawHook(function (t) {
          var v = -1 * t * SCALE;
          street.scroll(v);
          if (pos(b.id) >= 1.05) {
            clear();
            run();
          } else {
            rstc.time(t);
            msgBox.innerHTML = rstc.ttc(b.id, c.id).toFixed(1);
          }
        });

        var rstc = new ChangingRstc(new Rstc(addM({}, c, b, {ntg:-4.5, ttc:10})));
        rstc.forceReferenceCar(c.id);
        rstc = rstc.wait(0);

        function pos(car) {
          var refpos = 0.5;
          return SCALE * rstc.x(car) + refpos;
        }
      }

      addSlideInitializer("ttc-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("ttc-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="comb-slide">
  <h1>What NTG <span id="comb-title" style="visibility: hidden;">+ TTC</span> tell us</h1>
  <div class="vcenter">
    <div id="comb-street-container" style="display: table;">

      <div style="display: table-row;">
        <div style="display: table-cell;">
          <p style="font-size: 75%; text-align: center;">
            ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-0-ntg1"></span> 0
            &nbsp;&nbsp;&nbsp; ntg(<span style="color:red;">c</span>, <span style="color:blue;">b</span>) <span id="comb-msg-0-ntg2"></span> 0
            <span id="comb-label-0-ttc">&nbsp;&nbsp;&nbsp; ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-0-ttc"></span> 0</span>
          </p>
          <div id="comb-street-0" class="street no-print" style="margin: 0.5ex 0.5em 1.5ex 0.5em;"></div>
        </div>

        <div style="display: table-cell;">
          <p style="font-size: 75%; text-align: center;">
            ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-1-ntg1"></span> 0
            &nbsp;&nbsp;&nbsp; ntg(<span style="color:red;">c</span>, <span style="color:blue;">b</span>) <span id="comb-msg-1-ntg2"></span> 0
            <span id="comb-label-1-ttc">&nbsp;&nbsp;&nbsp; ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-1-ttc"></span> 0</span>
          </p>
          <div id="comb-street-1" class="street no-print" style="margin: 0.5ex 0.5em 1.5ex 0.5em;"></div>
        </div>
      </div>

      <div style="display: table-row;">
        <div style="display: table-cell;">
          <p style="font-size: 75%; text-align: center; padding-top: 1ex;">
            ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-2-ntg1"></span> 0
            &nbsp;&nbsp;&nbsp; ntg(<span style="color:red;">c</span>, <span style="color:blue;">b</span>) <span id="comb-msg-2-ntg2"></span> 0
            <span id="comb-label-2-ttc">&nbsp;&nbsp;&nbsp; ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-2-ttc"></span> 0</span>
          </p>
          <div id="comb-street-2" class="street no-print" style="margin: 0.5ex 0.5em 1.5ex 0.5em;"></div>
        </div>

        <div style="display: table-cell;">
          <p style="font-size: 75%; text-align: center; padding-top: 1ex;">
            ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-3-ntg1"></span> 0
            &nbsp;&nbsp;&nbsp; ntg(<span style="color:red;">c</span>, <span style="color:blue;">b</span>) <span id="comb-msg-3-ntg2"></span> 0
            <span id="comb-label-3-ttc">&nbsp;&nbsp;&nbsp; ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-3-ttc"></span> 0</span>
          </p>
          <div id="comb-street-3" class="street no-print" style="margin: 0.5ex 0.5em 1.5ex 0.5em;"></div>
        </div>
      </div>

      <div style="display: table-row;" id="comb-streets-ttc" class="incremental at-once">
        <div style="display: table-cell;">
          <p id="comb-street-4-desc" style="font-size: 75%; text-align: center; padding-top: 1ex;">
            ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-4-ntg1"></span> 0
            &nbsp;&nbsp;&nbsp; ntg(<span style="color:red;">c</span>, <span style="color:blue;">b</span>) <span id="comb-msg-4-ntg2"></span> 0
            <span id="comb-label-4-ttc">&nbsp;&nbsp;&nbsp; ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-4-ttc"></span> 0</span>
          </p>
          <div id="comb-street-4" class="street no-print" style="margin: 0.5ex 0.5em 1.5ex 0.5em;"></div>
        </div>

        <div style="display: table-cell;">
          <p id="comb-street-5-desc" style="font-size: 75%; text-align: center; padding-top: 1ex;">
            ntg(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-5-ntg1"></span> 0
            &nbsp;&nbsp;&nbsp; ntg(<span style="color:red;">c</span>, <span style="color:blue;">b</span>) <span id="comb-msg-5-ntg2"></span> 0
            <span id="comb-label-5-ttc">&nbsp;&nbsp;&nbsp; ttc(<span style="color:blue;">b</span>, <span style="color:red;">c</span>) <span id="comb-msg-5-ttc"></span> 0</span>
          </p>
          <div id="comb-street-5" class="street no-print" style="margin: 0.5ex 0.5em 1.5ex 0.5em;"></div>
        </div>
      </div>
    </div>
    <p id="comb-par" style="position: relative; width: 100%; text-align: center; visibility: hidden;">NTG + TTC tell us how two cars interrelate</p>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetIds = new Array();
      for (var i = 0; i < 6; ++i) {
        streetIds[i] = "comb-street-"+ i;
      }

      // Given NTG and its symmetric NTG, we can compute TTC:
      // ntg(b,c) := [x(c) - x(b)] / v(b)
      // ntg(c,b) := [x(b) - x(c)] / v(c)
      // 1/ntg(b,c) = v(b) / [x(c) - x(b)]
      // 1/ntg(c,b) = - v(c) / [x(c) - x(b)]
      // 1 / {1/ntg(b,c) + 1/ntg(c,b)} = 1 / {v(b) / [x(c) - x(b)] - v(c) / [x(c) - x(b)]}
      //                               = 1 / {[v(b) - v(c)] / [x(c) - x(b)]}
      //                               = [x(c) - x(b)] / [v(b) - v(c)]
      //                               = ttc(b,c)
      function ntg2ttc(ntg1, ntg2) { return 1 / (1 / ntg1 + 1 / ntg2); }

      function signum(x) { return (x > 0) - (x < 0); }

      var ms = new Array();
      ms[0] = {ntg1: 6  , ntg2: 6  , ref: "c", offset: 0.5, pull: true};
      ms[1] = {ntg1:-0.5, ntg2:-0.5, ref: "b", offset: 0.5, pull: true};
      ms[2] = {ntg1: 2  , ntg2:-2.5, ref: "c", offset: 0.35, pull: false};
      ms[3] = {ntg1:-2.5, ntg2: 2  , ref: "b", offset: 0.35, pull: false};
      ms[4] = {ntg1: 2.5, ntg2:-2  , ref: "b", offset: 0.35, pull: false};
      ms[5] = {ntg1:-2  , ntg2: 2.5, ref: "c", offset: 0.35, pull: false};

      var timer = new Array();

      function clear(i) {
        if (i == undefined) {
          for (i = 0; i < streetIds.length; ++i) {
            clear(i);
          }
          return;
        }

        if (timer[i] != null)
          timer[i].stop();
        timer[i] = null;
        removeChildren(streetIds[i]);
      }

      function run(i) {
        if (i == undefined) {
          for (i = 0; i < streetIds.length; ++i) {
            run(i);
          }
          return;
        }

        timer[i] = new Timer();
        var street = new Street(streetIds[i], timer[i], 2, { lines: 0, relWidth: 0.5 });
        var labels = { ntg1 : document.getElementById("comb-msg-"+ i +"-ntg1"),
                       ntg2 : document.getElementById("comb-msg-"+ i +"-ntg2"),
                       ttc  : document.getElementById("comb-msg-"+ i +"-ttc") };

        var lastPos = {};

        function pos(car) {
          if (!lastPos[car]) {
            var refpos = ms[i].offset + (ms[i].pull ? (SCALE * rstc.x(c.id) - SCALE * rstc.x(b.id)) / 2 : 0);
            var p = SCALE * rstc.x(car) + refpos;
            lastPos[car] = { t: 0, p: p };
          }
          lastPos[car].p += rstc.v(car) * (rstc.time() - lastPos[car].t) * SCALE;
          lastPos[car].t = rstc.time();
          return lastPos[car].p;
        }

        var bL2R = undefined;
        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return 1; },
          { radf: function (t) { if (bL2R == undefined) bL2R = rstc.v(b.id) >= 0; return bL2R ? 0 : Math.PI; } }
        );

        var cL2R = undefined;
        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; },
          { radf: function (t) { if (cL2R == undefined) cL2R = rstc.v(c.id) >= 0; return cL2R ? 0 : Math.PI; } }
        );

        street.addRedrawHook(function (t) {
          rstc.time(t);
          var ntg1 = rstc.ntg(b.id, c.id);
          var ntg2 = rstc.ntg(c.id, b.id);
          var ttc = rstc.ttc(b.id, c.id);
          if (pos(b.id) <= 0 || pos(c.id) <= 0 ||
              pos(b.id) >= 1 || pos(c.id) >= 1 ||
              signum(ntg1) != signum(ms[i].ntg1) ||
              signum(ntg2) != signum(ms[i].ntg2)) {
            clear(i);
            run(i);
            return;
          }
          labels.ntg1.innerHTML = ntg1 > 0 ? "&gt;" : ntg1 == 0 ? "=" : "&lt;";
          labels.ntg2.innerHTML = ntg2 > 0 ? "&gt;" : ntg2 == 0 ? "=" : "&lt;";
          labels.ttc.innerHTML = ttc > 0 ? "&gt;" : ttc == 0 ? "=" : "&lt;";
        });

        var m = { ntg: ms[i].ntg1, ttc: ntg2ttc(ms[i].ntg1, ms[i].ntg2) };
        var rstc = new ChangingRstc(new Rstc(addM({}, b, c, m)));
        rstc = rstc.wait(0);
        if (ms[i].ref != undefined) {
          rstc.forceReferenceCar(ms[i].ref);
        }
      }

      addSlideInitializer("comb-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("comb-slide", function (slide) { clear(); });
      setNodeInitializer("comb-streets-ttc", function (node) {
        for (var i = 0; i < streetIds.length; ++i) {
          document.getElementById("comb-label-"+ i +"-ttc").style.visibility = "visible";
        }
        document.getElementById("comb-title").style.visibility = "visible";
        document.getElementById("comb-par").style.visibility = "visible";
      });
      setNodeFinalizer("comb-streets-ttc", function (node) {
        for (var i = 0; i < streetIds.length; ++i) {
          document.getElementById("comb-label-"+ i +"-ttc").style.visibility = "hidden";
        }
        document.getElementById("comb-title").style.visibility = "hidden";
        document.getElementById("comb-par").style.visibility = "hidden";
      });
    })();
  </script>
</div>


<div class="slide" id="symmetry-transitivity-slide">
  <h1>Symmetry and Transitivity</h1>
  <div class="hcenter vcenter">
    <div id="symmetry-transitivity-street" class="street no-print"></div>
    <div id="symmetry-transitivity-par" style="width: 100%; display: none; position: absolute; text-align: center;">
      <div style="display: inline-block; text-align: left;">
        <p>Given: &nbsp; chain of NTG + TTC measurements</p>
        <p>Want: &nbsp; all NTG + TTC pairs</p>
      </div>
    </div>
    <div id="symmetry-transitivity-show-symmetry" class="incremental at-once no-print" style="display: none;"></div>
    <div id="symmetry-transitivity-show-transitivity" class="incremental at-once no-print" style="display: none;"></div>
    <!-- <div id="symmetry-transitivity-show-symmetry-and-transitivity" class="incremental at-once no-print" style="display: none;"></div> -->
    <div id="symmetry-transitivity-formulas" class="incremental at-once formula-table">
      <div class="tr">
        <div class="td">
          $\ntg(\c, \b) = \frac{-1}{1 - \frac{\ntg(\b, \c)}{\ttc(\b, \c)}} \cdot \ntg(\b, \c)$
        </div>
        <div class="td">
          $\ntg(\b, \d) = \ntg(\b, \c) + \big(1 - \tfrac{\ntg(\b, \c)}{\ttc(\b, \c)}\big) \cdot \ntg(\c, \d)$
        </div>
      </div>
      <div class="tr">
        <div class="td">
          $\ttc(\c, \b) = \ttc(\b, \c)$
        </div>
        <div class="td">
          $\ttc(\b, \d) = \lambda_1 \cdot \ttc(\b, \c) + \lambda_2 \cdot \ttc(\c, \d)$
          <div style="display: block; padding-top: 2ex; padding-left: 2em; padding-bottom: 1ex;">
            $\small \lambda_1
            \defeq \tfrac{\ttc(\c, \d) \cdot \ntg(\b, \c)}
                         {\ntg(\c, \d) \cdot \ttc(\b, \c)
                        + \ttc(\c, \d) \cdot \ntg(\b, \c)
                        - \ntg(\c, \d) \cdot \ntg(\b, \c)}$
          </div>
          <div style="display: block; padding-top: 2ex; padding-left: 2em; padding-bottom: 1ex;">
            $\small \lambda_2
            \defeq \tfrac{\ttc(\b, \c) \cdot \ntg(\c, \d)
                        - \ntg(\b, \c) \cdot \ntg(\c, \d)}
                         {\ntg(\b, \c) \cdot \ttc(\c, \d)
                        + \ttc(\b, \c) \cdot \ntg(\c, \d)
                        - \ntg(\b, \c) \cdot \ntg(\c, \d)}$
          </div>
        </div>
      </div>
    </div>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetId = "symmetry-transitivity-street";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren([streetId]);
      }

      function run() {
        timer = new Timer();
        var street = new Street(streetId, timer, 2, { offset: "30%", fps: 5 });

        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return 1; }
        );

        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; }
        );

        var d = new Elem("d", "car-green", street,
          function (t) { return pos(d.id); },
          function (t) { return 1; }
        );

        var rstc = new ChangingRstc(new Rstc(addM(addM({}, b, c, {ntg:2.2, ttc:4}), c, d, {ntg:3.5, ttc:15})));

        var refpos = undefined;
        for (var bb in rstc.cars) {
          var tmp = Math.abs(rstc.x(bb));
          if (refpos == undefined || tmp > refpos) {
            refpos = tmp;
          }
        }
        refpos = SCALE * refpos / 2;

        function pos(car) {
          return SCALE * rstc.x(car) + refpos;
        }

        var arrowOffset = -1 * 0.15 * b.width;
        var arrowWidth = 0.08 * b.width;
        var vis1a = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, b, c), { color: "black", line: 0, arrowHeadOffset: arrowOffset, arrowWidth: arrowWidth });
        var vis1b = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, c, d), { color: "black", line: 1, arrowWidth: arrowWidth });
        var vis2a = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, c, b), { color: "orange", line: 0, arrowStumpOffset: arrowOffset, arrowWidth: arrowWidth });
        var vis2b = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, d, c), { color: "orange", line: 1, arrowWidth: arrowWidth });
        var vis3 = new RstcVis(rstc, addS({}, [b, c, d]), street, addM(addM({}, b, d), d, b), { color: "#d000d0", line: 2, arrowStumpOffset: arrowOffset, arrowHeadOffset: arrowOffset, arrowWidth: arrowWidth });
        vis1a.enable();
        vis1b.enable();
        setNodeInitializer("symmetry-transitivity-show-symmetry", function (node) { vis2a.enable(); vis2b.enable(); });
        setNodeFinalizer("symmetry-transitivity-show-symmetry", function (node) { vis2a.disable(); vis2b.disable(); });
        setNodeInitializer("symmetry-transitivity-show-transitivity", function (node) { vis3.enable(); });
        setNodeFinalizer("symmetry-transitivity-show-transitivity", function (node) { vis3.disable(); });
        setNodeInitializer("symmetry-transitivity-formulas", function (node) { document.getElementById("symmetry-transitivity-par").style.display = "none"; });
        setNodeFinalizer("symmetry-transitivity-formulas", function (node) { document.getElementById("symmetry-transitivity-par").style.display = "block"; });
      }

      addSlideInitializer("symmetry-transitivity-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("symmetry-transitivity-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="time-and-acceleration-slide">
  <h1>Time and Acceleration</h1>
  <div class="hcenter vcenter">
    <div id="time-and-acceleration-street" class="street no-print"><div id="time-and-acceleration-street-label" class="street-label unremovable">Time: <span id="time-and-acceleration-street-label-timestamp">0</span> s</div></div>
    <div id="time-and-acceleration-par" style="position: absolute; width: 100%;">
      <div style="text-align: center;">Acceleration = discontinuous change of velocity by a relative factor</div>
    </div>
    <div id="time-and-acceleration-lapse-time" class="incremental no-print" style="display: none;"></div>
    <!--
    <div id="time-and-acceleration-do-nothing" class="incremental no-print" style="display: none;"></div>
    <div id="time-and-acceleration-do-action" class="incremental no-print" style="display: none;"></div>
    -->
    <div id="time-and-acceleration-formulas" class="incremental at-once formula-table">
      <div class="tr">
        <div class="td">
          $\tntg(\b,\c,t) = \ntg(\b,\c) - t \cdot \tfrac{\ntg(\b,\c)}{\ttc(\b,\c)}$
        </div>
        <div class="td">
          $\antg_1(\b, \c, q) = \tfrac{1}{q} \cdot \ntg(\b, \c)$
          <!-- <div style="padding-top: 1ex;">$\antg_2(\b, \c, q) = \ntg(\b, \c)$</div> -->
        </div>
      </div>
      <div class="tr">
        <div class="td">
          $\tttc(\b,\c,t) = \ttc(\b,\c) - t$
        </div>
        <div class="td">
          $\attc_1(\b, \c, q) = \frac{1}{(q - 1) \cdot \frac{\ttc(\b, \c)}{\ntg(\b, \c)} + 1} \cdot \ttc(\b, \c)$
          <!-- <div style="padding-top: 1ex;">$\attc_2(\b, \c, q) = \frac{1}{(1 - q) \cdot \frac{\ttc(\b, \c)}{\ntg(\b, \c)} + q} \cdot \ttc(\b, \c)$</div> -->
          <p style="margin-left: 0;">
          <span style="font-size: 80%;">Similarly </span>$\small \antg_2(\b,\c,q)$<span style="font-size: 80%;">, </span>$\small \attc_2(\b,\c,q)$<span style="font-size: 80%;"> for </span>$\small \c$<span style="font-size: 80%;"> accelerating.</span>
          </p>
          <!-- Ugly display (large spacing around subscripts) of MathJax HTML-CSS:
          <p style="margin-left: 0; font-size: 80%">
          Similarly $\antg_1(\b,\c,q)$, $\attc_2(\b,\c,q)$ for $\c$ accelerating.
          </p>
          -->
        </div>
      </div>
    </div>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetId = "time-and-acceleration-street";
      var labelId = streetId + "-label";
      var timestampId = labelId + "-timestamp";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren([streetId]);
      }

      function run() {
        timer = new Timer();
        var street = new Street(streetId, timer, 2, { offset: "20%", linesTop: 2, linesBottom: 1 });
        var label = document.getElementById(labelId);
        var timestamp = document.getElementById(timestampId);

        label.style.top = street.pavementTopHeight() +"px";

        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return 1; }
        );

        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; }
        );

        var rstc = new ChangingRstc(new Rstc(addM({}, c, b, {ntg:-3.75, ttc:20})));
        rstc.forceReferenceCar(c.id);
        rstc = rstc.wait(0);

        function pos(car) {
          var refpos = 0.5;
          return SCALE * rstc.x(car) + refpos;
        }

        var startAnimation = false;
        var automaticalTransitions = true;
        var MODES = { INIT : 0, DO_NOTHING : 1, LAPSE_TIME : 2, DO_ACTION : 3 };
        var DURATIONS = { INIT : 15, DO_NOTHING : 5, LAPSE_TIME : 10, DO_ACTION : 10 };
        var mode = MODES.INIT;
        var first = true;
        var tElapsed = 0;
        var tLastTimeLapse = 0;
        street.addRedrawHook(function (t) {
          if (mode == MODES.INIT) {
            if (first) {
              first = false;
              /* Transition to LAPSE_TIME done by overlay node handler:
              street.timer().addEvent(function () {
                mode = MODES.LAPSE_TIME;
                first = true;
              }, DURATIONS.INIT);
              */
            }
            timestamp.innerHTML = tElapsed.toFixed(1);
            if (startAnimation) {
              mode = MODES.LAPSE_TIME;
              first = true;
            }
          } else if (mode == MODES.LAPSE_TIME) {
            if (!first) {
              tElapsed += t - tLastTimeLapse;
            } else {
              tLastTimeLapse = t;
            }
            street.scroll(-1 * tElapsed * SCALE);
            timestamp.innerHTML = tElapsed.toFixed(1);
            rstc.time(rstc.time() + t - tLastTimeLapse);
            tLastTimeLapse = t;
            if (first) {
              first = false;
              street.timer().addEvent(function () {
                if (!automaticalTransitions) {
                  return;
                }
                mode = MODES.DO_NOTHING;
                first = true;
              }, DURATIONS.LAPSE_TIME);
            }
          } else if (mode == MODES.DO_NOTHING) {
            if (first) {
              first = false;
              street.timer().addEvent(function () {
                if (!automaticalTransitions) {
                  return;
                }
                mode = MODES.DO_ACTION;
                first = true;
              }, DURATIONS.DO_NOTHING);
            }
          } else if (mode == MODES.DO_ACTION) {
            if (tElapsed == 0) {
              return;
            }
            if (first) {
              first = false;
              var accel = 1 + (rstc.x(c.id) - rstc.x(b.id)) * SCALE;
              rstc = rstc.accel(b.id, accel).progress().wait(0);
              addAccelSymbol(street, b, accel, automaticalTransitions ? DURATIONS.DO_ACTION : undefined);
              var i = street.addRedrawHook(function (t1) {
                if (mode == MODES.DO_ACTION) {
                  street.ctx.save();
                  street.ctx.fillStyle = "black";
                  street.ctx.font = "bold "+ street.textHeight() +"px sans-serif";
                  //var str = (accel > 1 ? "ac" : "de") + "celerated by "+ accel.toFixed(2) +" ("+ (t1 - t).toFixed(1) +" s ago)";
                  var str = (accel > 1 ? "ac" : "de") + "celerate by "+ accel.toFixed(2);
                  var width = street.ctx.measureText(str).width;
                  var x = street.x(b.xf(t1)) - width / 2;
                  var y = street.textY(top, 1);
                  street.ctx.fillText(str, x, y);
                  //street.ctx.strokeText(str, x, y);
                  street.ctx.restore();
                }
              });
              street.timer().addEvent(function () { street.removeRedrawHook(i); }, DURATIONS.DO_ACTION);
              street.timer().addEvent(function () {
                if (!automaticalTransitions) {
                  return;
                }
                mode = MODES.LAPSE_TIME;
                first = true;
              }, DURATIONS.DO_ACTION);
            }
          }
        });

        var arrowWidth = 0.08 * b.width;
        var vis1 = new RstcVis(rstc, addS({}, [b, c]), street, addM(addM({}, c, b), b, c), { color: "black", lane: 0, arrowWidth: arrowWidth });
        vis1.enable();

        if (automaticalTransitions) {
          setNodeInitializer("time-and-acceleration-lapse-time", function (node) { startAnimation = true; });
        } else if (automaticalTransitions) {
          setNodeInitializer("time-and-acceleration-lapse-time", function (node) { mode = MODES.LAPSE_TIME; first = true; });
          setNodeFinalizer("time-and-acceleration-lapse-time", function (node) { mode = MODES.DO_NOTHING; first = true; });
          setNodeInitializer("time-and-acceleration-do-nothing", function (node) { mode = MODES.DO_NOTHING; first = true; });
          setNodeFinalizer("time-and-acceleration-do-nothing", function (node) { mode = MODES.LAPSE_TIME; first = true; });
          setNodeInitializer("time-and-acceleration-do-action", function (node) { mode = MODES.DO_ACTION; first = true; });
          setNodeFinalizer("time-and-acceleration-do-action", function (node) { mode = MODES.DO_NOTHING; first = true; });
        }
        setNodeInitializer("time-and-acceleration-formulas", function (node) { document.getElementById("time-and-acceleration-par").style.display = "none"; });
        setNodeFinalizer("time-and-acceleration-formulas", function (node) { document.getElementById("time-and-acceleration-par").style.display = "block"; });
      }

      addSlideInitializer("time-and-acceleration-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("time-and-acceleration-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="sitcalc-slide">
  <h1>Situation Calculus</h1>
  <div class="vcenter hcenter">
    <p>Reiter's Situation Calculus:</p>
    <ul>
      <!-- <li>Reasoning about actions and change</li> -->
      <li>Basic Action Theory: FOL sentences about
      <ul>
        <li>fluent values in initial situation $S_0$</li>
        <li>how actions affect fluent values in situations $\m{do}(a,s)$</li>
        <li>action preconditions $\m{Poss}(a, s)$</li>
      </ul>
      </li>
      <!-- <li>Situation terms $S_0$, $\m{do}(a, s)$</li> -->
      <!-- <li>Action effects are instantaneous<li> -->
      <!-- <li>Fluents are situation-dependent predicates and functions</li> -->
      <!-- <li>Successor State Axiom:
      $ F(\vec{x}, \m{do}(a,s)) \equiv \gamma^+_F(\vec{x}, a, s) \vee F(\vec{x}, s) \wedge \neg \gamma^-_F(\vec{x}, a, s) $ -->
      <li>Action language Golog
      <ul>
        <li>program execution builds up a situation term</li>
        <li>nondeterminism</li>
      </ul>
      </li>
    </ul>
  </div>
</div>


<div class="slide" id="bat-slide">
  <h1>Situation Calculus Theory</h1>
  <div class="vcenter hcenter">
    <ul>
      <li>Fluents: &nbsp;
        $\NTG(b,c,r,s)$, &nbsp;
        $\TTC(b,c,r,s)$, &nbsp;
        $\m{lane}(b, s) = \ell$
      <ul>
        <li>Represent partial functions $\ntg(b,c,s) = r$, &nbsp; $\ttc(b,c,s) = r$
        <li>Situation parameter $s$ encodes time and acceleration</li>
      </ul>
      </li>
      <li>Actions: &nbsp;
        $\m{accel}(b, q)$, &nbsp;
        $\m{wait}(t)$, &nbsp;
        $\m{lc}(b, \ell)$
      </li>
      <!-- <li>Initial situation: $\D_{S_0}$ contains chain of measurements -->
      <li>Initial situation: contains chain of measured values
      <ul>
        <li>Complete knowledge</li>
        <li>Symmetry and transitivity are state constraints</li>
        <!--
        <li>$\D \models \phi(S_0) \wedge \psi(S_0) \wedge \m{executable}(s) \supset \phi(s)\wedge \psi(s) $<br />
        where $\phi(s)$ specifies symmetry and transitivity wrt $s$<br />
        and $\psi(s)$ specifies that $\NTG$ and $\TTC$ represent partial functions</li>
        -->
      </ul>
      </li>
    </ul>
  </div>
</div>


<div class="slide" id="ntg-ssa-slide">
  <h1>Situation Calculus Theory</h1>
  <div class="vcenter hcenter">
    <div style="position: fixed; bottom: 3ex; right: 3ex;">
      <div class="box">
        If $t_i$ contains $\ntg(b,c,s)$ then $t_1 = t_2$ expands to<br />
        $\exists r \, \big(\NTG(b,c,r,s) \wedge (t_1)^{\ntg(b,c,s)}_r = (t_2)^{\ntg(b,c,s)}_r\big)$.<br />
        Analogously for $\ttc(b,c,s)$ and $\frac{x}{y}$.
      </div>
    </div>
    <p>Successor State Axiom for NTG:</p>
    \begin{align*}
    & \NTG(b, c, r, \m{do}(a, s)) \equiv{}\\
    & \quad
        \exists t \, \left(
        a = \m{wait}(t) \wedge %\ttc(b, c, s) \neq 0 \wedge{}
        r = \ntg(b, c, s) - t \cdot \tfrac{\ntg(b, c, s)}{\ttc(b, c, s)}
        \right) \; \vee{}\\
    & \quad
        \exists q \, \left(
        a = \m{accel}(b, q) \wedge %q \neq 0 \wedge{}
        r = \tfrac{1}{q} \cdot \ntg(b, c, s)
        \right) \; \vee{}\\
    & \quad
        \NTG(b, c, r, s) \wedge
        \forall t \, a \neq \m{wait}(t) \wedge{}
        \forall q \, a \neq \m{accel}(b, q)
    \end{align*}
    <p style="margin-top: 4ex; margin-left: 0px;">$\TTC$ analogously.</p>
  </div>
</div>


<div class="slide" id="all-inclusive-slide">
  <h1>The Model in Action</h1>
  <div class="vcenter hcenter">
    <div id="all-inclusive-street" class="street no-print"><div id="all-inclusive-street-label" class="street-label unremovable">Time: <span id="all-inclusive-street-label-timestamp">0</span> s</div></div>
    <div style="width: 100%; text-align: center;">
      <div id="all-inclusive-ds0" class="situation" style="margin-bottom: 1ex; text-align: center;">
      </div>
    </div>
    <div style="width: 100%; text-align: center;">
      <div id="all-inclusive-sit" class="situation dynamic-situation">
        <div class="s0 unremovable">S<sub>0</sub></div>
      </div>
    </div>
    <div id="all-inclusive-show-symmetry-and-transitivity" class="incremental at-once no-print" style="display: none;"></div>
    <div id="all-inclusive-start" class="incremental at-once no-print" style="display: none;"></div>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var streetId = "all-inclusive-street";
      var labelId = streetId + "-label";
      var timestampId = labelId + "-timestamp";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren([streetId, "all-inclusive-sit"]);
      }

      function run() {
        timer = new Timer();
        var street = new Street(streetId, timer, 3, { offset: "20%", lines: 3 });
        var label = document.getElementById(labelId);
        var globalTimestamp = document.getElementById(timestampId);
        label.style.top = street.pavementTopHeight() +"px";

        var b = new Elem("b", "car-blue", street,
          function (t) { return pos(b.id); },
          function (t) { return -1; }
        );

        var c = new Elem("c", "car-red", street,
          function (t) { return pos(c.id); },
          function (t) { return 0; }
        );

        var d = new Elem("d", "car-green", street,
          function (t) { return pos(d.id); },
          function (t) { return 1; }
        );

        var measurements = addM(addM({}, b, c, {ntg:3, ttc:-100}), c, d, {ntg:2, ttc:15});
        var rstc0 = new Rstc(measurements).wait(0);
        rstc0.forceReferenceCar(c.id);
        var rstc = new ChangingRstc(rstc0);

        function pos(car) {
          //var refpos = 0.5 + (SCALE * rstc.x(c.id) - SCALE * rstc.x(b.id)) / 2;
          var refpos = 0.5;
          return SCALE * rstc.x(car) + refpos;
        };

        function carToColor(car) {
          var color = undefined;
          if (car == "b") {
            color = "blue";
          } else if (car == "c") {
            color = "red";
          } else if (car == "d") {
            color = "green";
          }
          return color;
        }

        var sit = document.getElementById("all-inclusive-sit");
        if (sit.firstChild && !sit.firstChild.nextSibling) {
          sit.firstChild.style.marginLeft = "0px";
        }

        var started = false;
        var tStartOffset = 0;
        var tSitOffset = 0;
        var haveFirstTimeAction = false;
        street.addRedrawHook(function (t) {
          globalTimestamp.innerHTML = (t - tStartOffset).toFixed(1);
          if (!started) {
            tStartOffset = t;
            return;
          }
          if (!haveFirstTimeAction) {
            addActionToSit(sit, rstc, "wait", undefined, {carToColor: carToColor});
            haveFirstTimeAction = true;
          }
          street.scroll(-1 * (t - tStartOffset) * SCALE);
          rstc.time(t - tSitOffset - tStartOffset);
          updateTimeInSit(sit, rstc);

          var cars = [b, c, d];
          var car = cars[Math.round(t + tSitOffset) % cars.length];
          if (car.id != rstc.computeReferenceCar()) {
            var dist = pos(rstc.computeReferenceCar()) - pos(car.id);
            if (rstc.time() > 7 && Math.abs(dist) > 0.3) {
              tSitOffset += rstc.time(); // new situation starts at time 0 again
              var accel = 1 + dist;
              rstc = rstc.accel(car.id, accel).progress().wait(0);
              addAccelSymbol(street, car, accel);
              addActionToSit(sit, rstc, "accel", [car.id, accel], {carToColor: carToColor});
              addActionToSit(sit, rstc, "wait", undefined, {carToColor: carToColor});
            }
          }
        });

        var str = "D<sub>S<sub>0</sub></sub> = { ";
        //var str = "\\small \\D_{S_0} = \\{";
        for (var bb in measurements) {
          for (var cc in measurements[bb]) {
            var bbb = "<span style=\"color: "+ carToColor(bb) +";\">"+ bb +"</span>";
            var ccc = "<span style=\"color: "+ carToColor(cc) +";\">"+ cc +"</span>";
            //var bbb = "{\\color{"+ carToColor(bb) +"}"+ bb +"}";
            //var ccc = "{\\color{"+ carToColor(cc) +"}"+ cc +"}";
            if (measurements[bb][cc].ntg) {
              str += "\NTG("+ bbb +", "+ ccc +", "+ measurements[bb][cc].ntg.toFixed(1) +", S<sub>0</sub>), ";
              //str += "\\NTG("+ bbb +", "+ ccc +", "+ measurements[bb][cc].ntg.toFixed(1) +", S_0), ";
            }
            if (measurements[bb][cc].ttc) {
              str += "\TTC("+ bbb +", "+ ccc +", "+ measurements[bb][cc].ttc.toFixed(1) +", S<sub>0</sub>), ";
              //str += "\\TTC("+ bbb +", "+ ccc +", "+ measurements[bb][cc].ttc.toFixed(1) +", S_0), ";
            }
          }
        }
        str += "&phi;(S<sub>0</sub>) }";
        //str += "\\phi(S_0) \\}";
        var ds0 = document.getElementById("all-inclusive-ds0");
        ds0.innerHTML = str;
        ds0.style.visibility = "visible";
        //repeatForSuccess(function () { renderTeX(str, "all-inclusive-s0"); });
        setTimeout(function() {
          sit.style.width = ds0.clientWidth +"px";
          sit.style.height = ds0.clientheight +"px";
        }, 10);

        var arrowOffset = -1 * 0.15 * b.width;
        var arrowWidth = 0.08 * b.width;
        var vis1a = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, b, c), { color: "black", line: 0, arrowHeadOffset: arrowOffset, arrowWidth: arrowWidth });
        var vis1b = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, c, d), { color: "black", line: 1, arrowWidth: arrowWidth });
        var vis2a = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, c, b), { color: "orange", line: 0, arrowStumpOffset: arrowOffset, arrowWidth: arrowWidth });
        var vis2b = new RstcVis(rstc, addS({}, [b, c, d]), street, addM({}, d, c), { color: "orange", line: 1, arrowWidth: arrowWidth });
        var vis3 = new RstcVis(rstc, addS({}, [b, c, d]), street, addM(addM({}, b, d), d, b), { color: "#d000d0", line: 2, arrowStumpOffset: arrowOffset, arrowHeadOffset: arrowOffset, arrowWidth: arrowWidth });
        vis1a.enable();
        vis1b.enable();
        setNodeInitializer("all-inclusive-show-symmetry-and-transitivity", function (node) { vis2a.enable(); vis2b.enable(); vis3.enable(); });
        setNodeFinalizer("all-inclusive-show-symmetry-and-transitivity", function (node) { vis2a.disable(); vis2b.disable(); vis3.disable(); });
        setNodeInitializer("all-inclusive-start", function (node) { started = true; });
        setNodeFinalizer("all-inclusive-start", function (node) { started = false; });
      }

      addSlideInitializer("all-inclusive-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("all-inclusive-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="evaluation-slide">
  <h1>Application: Plan Recognition</h1>
  <div class="vcenter hcenter">
    <p>Our approach:</p>
    <ul>
      <li>Domain specification = Basic Action Theory</li>
      <li>Plan library = (nondeterministic) Golog programs
      <li>Simulate program execution, try to match with observations</li>
    </ul>
    <div>
      <div class="incremental at-once" id="evaluation-program-1" style="display: block;"></div>
      <div class="incremental at-once" id="evaluation-program-2" style="display: none;"></div>
      <div class="incremental at-once" id="evaluation-program-3" style="display: none;"></div>
      <div class="incremental at-once" id="evaluation-program-4" style="display: none;"></div>
    </div>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      function render() {
        var PROG = 
          "\\begin{align*}"+
              "& \\m{overtake}(b, c) \\defeq{}\\\\"+
              "& \\qquad MARK_START_1 (\\ntg(b, c) > 0 \\wedge \\ntg(c, b) < 0 \\wedge \\m{lane}(b) = \\m{lane}(c))? MARK_END_1 ;\\\\"+
              "& \\qquad \\big( \\quad MARK_START_2 \\m{lc}(b, \\m{lane}(b) + 1) ; MARK_END_2\\\\"+
              "& \\qquad \\; \\; \\quad MARK_START_2 \\m{wait}(\\m{until}(\\ntg(b, c) < 0 \\wedge \\ntg(c, b) > 0)) ; MARK_END_2\\\\"+
              "& \\qquad \\; \\; \\quad MARK_START_2 \\m{lc}(b, \\m{lane}(b) - 1) MARK_END_2\\\\"+
              "& \\qquad \\conc \\;\\; MARK_START_3 ((\\pi q) \\ ((q \\geq 1)? ; \\m{accel}(b, q)))^\\ast MARK_END_3 \\big) ;\\\\"+
              "& \\qquad MARK_START_4 (\\ntg(b, c) < 0 \\wedge \\ntg(c, b) > 0)? MARK_END_4"+
          "\\end{align*}";
        for (var i = 1; i <= 4; ++i) {
          var p = PROG;
          p = p.replace(new RegExp("MARK_START_" + i, "g"), "\\color{blue}{");
          p = p.replace(new RegExp("MARK_END_" + i, "g"), "}");
          for (var j = 1; j <= 4; ++j) {
            p = p.replace(new RegExp("MARK_START_" + j, "g"), "");
            p = p.replace(new RegExp("MARK_END_" + j, "g"), "");
          }
          //renderTeX(p, "evaluation-program-"+ i);
          document.getElementById("evaluation-program-"+ i).innerHTML = p;
        }
      }

      function show(i) {
        for (var j = 1; j <= 4; ++j) {
          document.getElementById("evaluation-program-"+ j).style.display = (i == j ? "block" : "none");
        }
      }

      /* Two ways to do it:
       * 1. render LaTeX dynamically using slide initializer + renderTeX()
       * 2. initialize the DIVs before MathJax is loaded. */
      render();
      if (window.MathJax && MathJax.Hub && MathJax.Hub.Queue) {
        MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
      }
      //addSlideInitializer("evaluation-slide", function (slide) { render(); });

      setNodeInitializer("evaluation-program-1", function (node) { show(1); });
      setNodeInitializer("evaluation-program-2", function (node) { show(2); });
      setNodeInitializer("evaluation-program-3", function (node) { show(3); });
      setNodeInitializer("evaluation-program-4", function (node) { show(4); });
      setNodeFinalizer("evaluation-program-1", function (node) { });
      setNodeFinalizer("evaluation-program-2", function (node) { show(1); });
      setNodeFinalizer("evaluation-program-3", function (node) { show(2); });
      setNodeFinalizer("evaluation-program-4", function (node) { show(3); });
    })();
  </script>
</div>


<div class="slide" id="system-slide">
  <h1>Plan Recognition System</h1>
  <div class="vcenter hcenter">
    <img src="graphics/torcs.png" alt="" style="position: absolute; top: 0; right: 0; width: 40%; z-index: -10;" />
    <p>Driving Simulator:</p>
    <ul>
      <li>Adapted racing game TORCS</li>
      <li>Complete knowledge</li>
      <li>Two observations per second</li>
    </ul>
    <p style="padding-top: 1ex;">Plan Recognition System:</p>
    <ul>
      <li><a href="http://www.github.com/schwering/prgolog">Golog interpreter (written in Haskell)</a></li>
      <li>Executes concurrently
      <ul>
        <li>One program for each car</li>
        <li>Exogenous actions for observations</li>
      </ul>
      </li>
      <li>Decision-theoretically searches for the best execution</li>
    </ul>
  </div>
</div>


<div class="slide" id="evaluation-animation-slide">
  <h1>Plan Recognition Example</h1>
  <div class="vcenter hcenter">
    <div style="padding-left: 1em;">
      <ul>
        <li><span style="color: green;">green</span> passes <span style="color: blue;">blue</span> on the left lane and</li>
        <li><span style="color: red;">red</span> passes <span style="color: blue;">blue</span> with lane changes</li>
      </ul>
    </div>
    <div id="evaluation-animation-obs-street" class="street no-print"><div class="street-label unremovable">Observed scenario:</div></div>
    <div id="evaluation-animation-mod-street" class="street no-print"><div class="street-label unremovable">Reconstructed scenario:</div></div>
    <div style="width: 100%; text-align: center;">
      <div id="evaluation-animation-sit" class="situation dynamic-situation">
        <div class="s0 unremovable">S<sub>0</sub></div>
      </div>
    </div>
  </div>
  <script type="text/javascript">
    "use strict";

    (function () {
      var obsStreetId = "evaluation-animation-obs-street";
      var modStreetId = "evaluation-animation-mod-street";
      var timer = null;

      function clear() {
        if (timer != null)
          timer.stop();
        timer = null;
        removeChildren(obsStreetId);
        removeChildren(modStreetId);
        removeChildren("evaluation-animation-sit");
      }

      function run() {
        timer = new Timer();
        var obsStreet = new Street(obsStreetId, timer, 2, { offset: "5%" });
        var modStreet = new Street(modStreetId, timer, 2, { offset: "5%" });

        var b = new Elem("b", "car-blue", obsStreet,
          function (t) { return obsPos(b.id); },
          function (t) { return obsLat(b.id); }
        );

        var prevRad = undefined;
        var c = new Elem("c", "car-red", obsStreet,
          function (t) { return obsPos(c.id); },
          function (t) { return obsLat(c.id); },
          { radf: function (t) {
              var T = 0.5;
              var v = obsRstc.v(c.id);
              if (v < 0 && prevRad) { return prevRad; } // at the point where c passes the reference car (time 10.22), there is some inaccuracy and therefore the orientation shortly flips to -178 degrees for a moment
              var x = v * T * scale * obsStreet.streetWidth();
              var y = (obsLat(c.id, T/2) - obsLat(c.id, -T/2)) * obsStreet.laneHeight();
              var rad = -1 * Math.atan2(y, x);
              prevRad = rad;
              return rad;
            }
          }
        );

        var d = new Elem("d", "car-green", obsStreet,
          function (t) { return obsPos(d.id); },
          function (t) { return obsLat(d.id); }
        );

        var bb = new Elem("b", "car-blue", modStreet,
          function (t) { return modPos(bb.id); },
          function (t) { return modLat(bb.id); }
        );

        var cc = new Elem("c", "car-red", modStreet,
          function (t) { return modPos(cc.id); },
          function (t) { return modLat(cc.id); }
        );

        var dd = new Elem("d", "car-green", modStreet,
          function (t) { return modPos(dd.id); },
          function (t) { return modLat(dd.id); }
        );


        /* Generated from the observations:
         * (The first four TTCs of d, c and are manipulated: actually they are negative (simply *(-1)), but then the visualization freaks a little bit out.) */
        var obs = [];
        obs[ 0] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99958), c, -2.72269), time: 0.0,                rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.2194798178683484,  ttc: 8.648448915364733}), b, d, {ntg: -3.270148936246922,  ttc: 16.35847076137299}))};
        obs[ 1] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -2.81641), time: 0.5180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.3129277550536953,  ttc: 21.781406594153285}), b, d, {ntg: -3.1718215614456713,  ttc: 15.775523398019555}))};
        obs[ 2] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -2.92857), time: 1.0180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.351491767261003,  ttc: 26.259368313737056}), b, d, {ntg: -3.0753685479708714,  ttc: 15.111641140031823}))};
        obs[ 3] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -2.93676), time: 1.5180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.3875754515066254,  ttc: 60.76415325295317}), b, d, {ntg: -2.969809447749812,  ttc: 14.850911465379475}))};
        obs[ 4] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -2.89504), time: 2.0180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.390986294307351,  ttc: 121.51708657810391}), b, d, {ntg: -2.8618264182646143,  ttc: 14.52479866825347}))};
        obs[ 5] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -2.91941), time: 2.5180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.366188542566704,  ttc: 30.017112323922174}), b, d, {ntg: -2.7572777408456615,  ttc: 14.154918624878384}))};
        obs[ 6] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -2.96037), time: 3.0180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.313272635774363,  ttc: 16.661018417075542}), b, d, {ntg: -2.6633219068223886,  ttc: 13.569477985231863}))};
        obs[ 7] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.00490), time: 3.5180000000000007, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.2272359789198775,  ttc: 11.343067077796535}), b, d, {ntg: -2.574889893295083,  ttc: 12.717983019406399}))};
        obs[ 8] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.05178), time: 4.018000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -2.116404072834841,  ttc: 8.27225555375385}), b, d, {ntg: -2.4784720896463557,  ttc: 12.224933032290744}))};
        obs[ 9] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.10091), time: 4.518000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -1.972688197109781,  ttc: 6.2969149156521125}), b, d, {ntg: -2.3731986757403503,  ttc: 11.82281779333595}))};
        obs[10] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.15249), time: 5.018000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -1.7987682349067018,  ttc: 4.607712567402612}), b, d, {ntg: -2.266490243385025,  ttc: 11.522954361822313}))};
        obs[11] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.19005), time: 5.518000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -1.5885921235680929,  ttc: 3.5765244108769503}), b, d, {ntg: -2.165176336035255,  ttc: 11.106158035737318}))};
        obs[12] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.17245), time: 6.018000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -1.3579241816214944,  ttc: 2.8701817909435894}), b, d, {ntg: -2.064302269909894,  ttc: 10.584377346268791}))};
        obs[13] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.13955), time: 6.518000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -1.1147937924275313,  ttc: 2.209613601531197}), b, d, {ntg: -1.9744532732216904,  ttc: 9.907043639666108}))};
        obs[14] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.10415), time: 7.018000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -0.8546088084924861,  ttc: 1.6022603630006889}), b, d, {ntg: -1.8781000629835725,  ttc: 9.28506081230673}))};
        obs[15] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.06781), time: 7.518000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: -0.5805613533636672,  ttc: 1.0296129869105577}), b, d, {ntg: -1.780808553445657,  ttc: 8.756683807369795}))};
        obs[16] = {y: addS(addS(addS({}, b, -3.00010), d,  2.99997), c, -3.03081), time: 8.018, rstc: new Rstc(addM(addM({}, d, c, {ntg: -0.2913808120924829,  ttc: 0.490693491061966}), b, d, {ntg: -1.6778650549225296,  ttc: 8.359681676627755}))};
        obs[17] = {y: addS(addS(addS({}, b, -3.00010), c, -2.97244), d,  2.99997), time: 8.528, rstc: new Rstc(addM(addM({}, d, c, {ntg: 1.901397237968931e-2,  ttc: -3.0558750225717017e-2}), b, d, {ntg: -1.5752371774851424,  ttc: 7.857364380131382}))};
        obs[18] = {y: addS(addS(addS({}, b, -3.00010), c, -1.67039), d,  2.99997), time: 9.034, rstc: new Rstc(addM(addM({}, d, c, {ntg: 0.3301326000875662,  ttc: -0.5858022517475057}), b, d, {ntg: -1.4695937907282182,  ttc: 7.5252205857993175}))};
        obs[19] = {y: addS(addS(addS({}, b, -3.00010), c,  1.43498), d,  2.99997), time: 9.540000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: 0.628082123413615,  ttc: -1.0771931887088986}), b, d, {ntg: -1.3668158120409482,  ttc: 7.065698927523447}))};
        obs[20] = {y: addS(addS(addS({}, b, -3.00010), c,  2.63471), d,  2.99997), time: 10.046000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: 0.9413410606568459,  ttc: -1.5925727566796297}), b, d, {ntg: -1.2692018649017742,  ttc: 6.436098944980726}))};
        obs[21] = {y: addS(addS(addS({}, c,  1.75313), b, -3.00010), d,  2.99997), time: 10.552000000000001, rstc: new Rstc(addM(addM({}, d, c, {ntg: 1.2615428477109372,  ttc: -1.930165712370343}), b, d, {ntg: -1.1740825780870687,  ttc: 5.762992988839594}))};
        obs[22] = {y: addS(addS(addS({}, c,  0.34964), b, -3.00010), d,  2.99997), time: 11.058000000000002, rstc: new Rstc(addM(addM({}, d, c, {ntg: 1.59613618271998,  ttc: -2.336325667673387}), b, d, {ntg: -1.073922168697868,  ttc: 5.2564235945235245}))};
        obs[23] = {y: addS(addS(addS({}, c, -1.12510), b, -3.00010), d,  2.99997), time: 11.564000000000002, rstc: new Rstc(addM(addM({}, d, c, {ntg: 1.9459747543897588,  ttc: -2.723549835142163}), b, d, {ntg: -0.969355055954789,  ttc: 4.860491825185001}))};
        obs[24] = {y: addS(addS(addS({}, c, -2.23395), b, -3.00010), d,  2.99997), time: 12.069999999999999, rstc: new Rstc(addM(addM({}, d, c, {ntg: 2.3125351841048665,  ttc: -3.136493087951892}), b, d, {ntg: -0.8642193919268024,  ttc: 4.483167411394709}))};
        obs[25] = {y: addS(addS(addS({}, c, -2.44377), b, -3.00010), d,  2.99997), time: 12.575999999999999, rstc: new Rstc(addM(addM({}, d, c, {ntg: 2.695715641018549,  ttc: -3.50862091901172}), b, d, {ntg: -0.7670943519941793,  ttc: 3.9167351913306496}))};
        obs[26] = {y: addS(addS(addS({}, c, -2.42682), b, -3.00010), d,  2.99997), time: 13.081999999999999, rstc: new Rstc(addM(addM({}, d, c, {ntg: 3.0922881172990766,  ttc: -3.8716424270439815}), b, d, {ntg: -0.6698224561413672,  ttc: 3.327118698801934}))};
        obs[27] = {y: addS(addS(addS({}, c, -2.47582), b, -3.00010), d,  2.99997), time: 13.588, rstc: new Rstc(addM(addM({}, d, c, {ntg: 3.5041110785025955,  ttc: -4.223583034689121}), b, d, {ntg: -0.5691883271951894,  ttc: 2.8249054167936682}))};
        obs[28] = {y: addS(addS(addS({}, c, -2.55034), b, -3.00010), d,  2.99997), time: 14.094, rstc: new Rstc(addM(addM({}, d, c, {ntg: 3.928485213698188,  ttc: -4.587573978210531}), b, d, {ntg: -0.46701038728017424,  ttc: 2.3564213879011247}))};
        obs[29] = {y: addS(addS(addS({}, c, -2.79178), b, -3.00010), d,  2.99997), time: 14.6, rstc: new Rstc(addM(addM({}, d, c, {ntg: 4.348849263569573,  ttc: -5.48111871258472}), b, d, {ntg: -0.3650692568307348,  ttc: 1.882160029315636}))};
        obs[30] = {y: addS(addS(addS({}, c, -2.33897), b, -3.00010), d,  2.99997), time: 15.106, rstc: new Rstc(addM(addM({}, d, c, {ntg: 4.760138120052651,  ttc: -5.807500100827517}), b, d, {ntg: -0.2645370148529989,  ttc: 1.3673343022824735}))};
        obs[31] = {y: addS(addS(addS({}, c, -1.64258), b, -3.00010), d,  2.99997), time: 15.612, rstc: new Rstc(addM(addM({}, d, c, {ntg: 5.179028931512441,  ttc: -5.794465508346141}), b, d, {ntg: -0.16602052781678697,  ttc: 0.8077761538326224}))};
        obs[32] = {y: addS(addS(addS({}, c, -1.87101), b, -3.00010), d,  2.99997), time: 16.118000000000002, rstc: new Rstc(addM(addM({}, d, c, {ntg: 5.636470490773903,  ttc: -5.947807611833369}), b, d, {ntg: -6.459175308145028e-2,  ttc: 0.32633575305736506}))};
        obs[33] = {y: addS(addS(addS({}, c, -2.49996), d,  2.99997), b, -3.00010), time: 16.624000000000002, rstc: new Rstc(addM(addM({}, d, c, {ntg: 6.1021316544842135,  ttc: -6.655865102255537}), b, d, {ntg: 3.608894043234964e-2,  ttc: -0.17579561303409078}))};
        obs[34] = {y: addS(addS(addS({}, c, -2.64950), d,  2.99997), b, -3.00010), time: 17.130000000000003, rstc: new Rstc(addM(addM({}, d, c, {ntg: 6.56946623060998,  ttc: -7.029910723745764}), b, d, {ntg: 0.135660786764199,  ttc: -0.6986699241960069}))};
        obs[35] = {y: addS(addS(addS({}, c, -2.60249), d,  2.99997), b, -3.00010), time: 17.636000000000003, rstc: new Rstc(addM(addM({}, d, c, {ntg: 7.024292820871982,  ttc: -7.807529380661074}), b, d, {ntg: 0.2361092548441379,  ttc: -1.202864861698854}))};
        obs[36] = {y: addS(addS(addS({}, c, -3.42082), d,  2.94886), b, -3.00010), time: 18.142000000000003, rstc: new Rstc(addM(addM({}, d, c, {ntg: 7.454646157474875,  ttc: -8.897346368213583}), b, d, {ntg: 0.34569183532548764,  ttc: -1.7034861325115533}))};
        obs[37] = {y: addS(addS(addS({}, c, -4.39893), d,  2.81914), b, -3.10693), time: 18.648000000000003, rstc: new Rstc(addM(addM({}, d, c, {ntg: 7.799849018288831,  ttc: -12.331368530904605}), b, d, {ntg: 0.46593937614763514,  ttc: -2.341085495515371}))};
        obs[38] = {y: addS(addS(addS({}, c, -4.04431), d,  2.77332), b, -3.24082), time: 19.154000000000003, rstc: new Rstc(addM(addM({}, d, c, {ntg: 8.116852496280107,  ttc: -15.620076134591532}), b, d, {ntg: 0.5856594746904928,  ttc: -3.035267945018255}))};
        obs[39] = {y: addS(addS(addS({}, c, -3.57002), d,  2.76656), b, -3.29832), time: 19.660000000000004, rstc: new Rstc(addM(addM({}, d, c, {ntg: 8.39884489054499,  ttc: -14.16869232112189}), b, d, {ntg: 0.7115625536111004,  ttc: -3.5935617271142157}))};
        obs[40] = {y: addS(addS(addS({}, c, -3.07328), d,  2.76747), b, -3.30780), time: 20.165999999999997, rstc: new Rstc(addM(addM({}, d, c, {ntg: 8.650096929473962,  ttc: -18.225102903605183}), b, d, {ntg: 0.8367693793574109,  ttc: -4.144629090531496}))};

        for (var i = 0; i < obs.length; ++i) {
          obs[i].rstc = new ChangingRstc(obs[i].rstc);
        }

        var obsRstc = new InterpolatingRstc(obs);
        obsRstc.forceReferenceCar(b.id);

        var scale = SCALE * 1.5;
        var refpos = 0.5;

        function obsPos(car) {
          return scale * obsRstc.x(car) + refpos;
        }

        function obsLat(car, t) {
          if (t == undefined) { t = 0; }
          t += obsRstc.time();
          for (var i = 0; i < obs.length; ++i) {
            if (t >= obs[i].time && i+1 < obs.length && t < obs[i+1].time) {
              var len = obs[i+1].time - obs[i].time;
              var rel = t - obs[i].time;
              var y = obs[i].y[car] + rel / len * (obs[i+1].y[car] - obs[i].y[car]);
              return (y / 2.5 + 1) / 2;
            }
          }
          return 0;
        }


        var modRstc = new ChangingRstc(new Rstc(addM(addM({}, d, c, {ntg: -2.2194798178683484,  ttc: -8.648448915364733}), b, d, {ntg: -3.270148936246922,  ttc: 16.35847076137299}))).wait(0);
        modRstc.forceReferenceCar(obsRstc.computeReferenceCar());
        var modLane = {};
        modLane[b.id] = 0;modLane[d.id] = 1;modLane[c.id] = 0;
        var tDone = -1;

        function modPos(car) {
          return scale * modRstc.x(car) + refpos;
        }

        function modLat(car) {
          return modLane[car];
        }

        function carToColor(car) {
          var color = undefined;
          if (car == "b") {
            color = "blue";
          } else if (car == "c") {
            color = "red";
          } else if (car == "d") {
            color = "green";
          }
          return color;
        }

        obsStreet.addRedrawHook(function (t) {
          if (t >= obs[obs.length-1].time) {
            clear();
            run();
            return;
          }
          obsRstc.time(t);
          obsStreet.scroll(-1 * t * scale);
        });

        var sit = document.getElementById("evaluation-animation-sit");
        if (sit.firstChild && !sit.firstChild.nextSibling) {
          sit.firstChild.style.marginLeft = "0px";
        }

        var tOffset = 0;
        var haveFirstTimeAction = false;
        var actSpec = {carToColor: carToColor, stepInPixels: 50, stepDuration: 40, precision: 2 };
        modStreet.addRedrawHook(function (t) {
          if (!haveFirstTimeAction) {
            addActionToSit(sit, modRstc, "wait", undefined, actSpec);
            haveFirstTimeAction = true;
          }
          updateTimeInSit(sit, modRstc);
          modStreet.scroll(-1 * t * scale);
          modRstc.time(t - tOffset);
          /* Generated from the model: */
          var tWait = 0;
          tWait += 0.5180000000000007;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.2934995007866792; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0977161737399035; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0770446558774798; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0407683512718324; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.048397085500897; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.115633187106443; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0509614090544614; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.046274288174613; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.04453579348881; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5;
          tWait += 0.5099999999999998;
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { var car = c.id; var lane = 1; modLane[car] = lane; addActionToSit(sit, modRstc, "lc", [car, lane+""], actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0236201384660044; var car = c.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { var car = c.id; var lane = 0; modLane[car] = lane; addActionToSit(sit, modRstc, "lc", [car, lane+""]); }
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 0.9942427626852177; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0001494892882365; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5059999999999967;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.000445503985134; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.001703051402799; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0017286479035759; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.0009320742994603; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 0.9999931571934657; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 0.9990977633852909; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.000668477038241; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 1.000074483000681; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          if (t > tWait && tDone < tWait) { tOffset += modRstc.time(); var q = 0.9994666022803753; var car = d.id; modRstc.accel(car, q).progress().wait(0); addActionToSit(sit, modRstc, "accel", [car, q], actSpec); addActionToSit(sit, modRstc, "wait", undefined, actSpec); tDone = tWait; }
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5060000000000002;
          tWait += 0.5059999999999967;
        });

        setTimeout(function() {
          sit.style.width = modStreet.streetWidth() +"px";
        }, 10);
      }

      addSlideInitializer("evaluation-animation-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("evaluation-animation-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="evaluation-graph-slide">
  <h1>Plan Recognition Example</h1>
  <div class="vcenter hcenter" id="evaluation-trace-container" style="width: 100%; height: 80%;">
    <p style="text-align: center;">Goal: execute program in a way that matches <i>observed</i> NTG + TTC with <i>model</i> NTG + TTC</p>
    <img id="evaluation-trace-obs" src="graphics/trace-obs.svg" style="display: none; position: absolute;" />
    <img id="evaluation-trace-mod" src="graphics/trace-mod.svg" style="display: none; position: absolute;" />
  </div>
  <div id="evaluation-graph-merge" class="incremental no-print" style="display: none;"></div>
  <script type="text/javascript">
    "use strict";
    (function () {
      var cont = document.getElementById("evaluation-trace-container");
      var obs = document.getElementById("evaluation-trace-obs");
      var mod = document.getElementById("evaluation-trace-mod");
      var slideIntervalId1 = null;
      var slideIntervalId2 = null;
      function run() {
        var width = cont.clientWidth / 2;
        obs.style.width = width +"px";
        obs.style.display = "block";
        obs.style.marginLeft = "0px";
        mod.style.width = width +"px";
        mod.style.display = "block";
        mod.style.marginLeft = width +"px";
        setNodeInitializer("evaluation-graph-merge", function (node) {
          function stepsRight (pctDone) {
            return 1 + 5 * Math.cos(pctDone * Math.PI - Math.PI / 2);
          }
          function stepsLeft (pctDone) {
            return -1 * stepsRight(pctDone);
          }
          slideIntervalId1 = slideElement(obs, 0,     width / 2, stepsRight, 10);
          slideIntervalId2 = slideElement(mod, width, width / 2, stepsLeft,  10);
        });
        setNodeFinalizer("evaluation-graph-merge", function (node) {
          if (slideIntervalId1 != null) { clearInterval(slideIntervalId1); }
          if (slideIntervalId2 != null) { clearInterval(slideIntervalId2); }
          obs.style.marginLeft = "0px";
          mod.style.marginLeft = width +"px";
        });
      }
      function clear() {
        if (slideIntervalId1 != null) { clearInterval(slideIntervalId1); }
        if (slideIntervalId2 != null) { clearInterval(slideIntervalId2); }
        obs.style.marginLeft = "0px";
        mod.style.marginLeft = "0px";
      }
      addSlideInitializer("evaluation-graph-slide", function (slide) { clear(); run(); });
      addSlideFinalizer("evaluation-graph-slide", function (slide) { clear(); });
    })();
  </script>
</div>


<div class="slide" id="conclusion-slide">
  <h1>Conclusion</h1>
  <div class="vcenter hcenter">
    <p>Conclusion:</p>
    <ul>
      <li>Temporal distances (NTG, TTC)</li>
      <li>No global information needed (no absolute velocities, no GPS)</li>
      <!-- <li>NTG + TTC to cars driving in front yield complete view of traffic</li> -->
      <li>Few NTG + TTC measurements give complete view of traffic</li>
      <li>Integrated time and simplified acceleration</li>
      <li>Used for on-line plan recognition</li>
    </ul>
    <div class="incremental at-once">
      <p style="margin-top: 3ex;">Future work:</p>
      <ul>
        <li>Sensing and incomplete knowledge</li>
        <li>Inaccurate measurements</li>
        <li>Larger-scale experiments</li>
        <li>Prediction of traffic situations</li>
        <!-- <li>Other logical formalisms than SitCalc / Golog</li> -->
      </ul>
    </div>
  </div>
</div>


</body>
</html>
